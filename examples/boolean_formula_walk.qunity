type Child :=
    | $Vleft
    | $Vright
end

type Coin := Maybe{Child} end

type Vertex{#n} := List{#n + 1, Child} end

type Leaf{#n} := Array{#n, Child} end

def $Cdown : Coin := $Nothing{Child} end
def $Cleft : Coin := @Just{Child}($Vleft) end
def $Cright : Coin := @Just{Child}($Vright) end

def $Root{#n} : Vertex{#n} := $ListEmpty{#n + 1, Child} end

def $Root'{#n} : Vertex{#n} :=
    @ListCons{#n + 1, Child}($Vleft, $ListEmpty{#n, Child})
end

def $u_state : Coin :=
    $0
    |> u3{2 * arccos(sqrt(1 / 3)), 0, 0}
    |> pmatch [
        $0 -> $Cdown;
        $1 -> @Just{Child}($plus |> pmatch [$0 -> $Vleft; $1 -> $Vright])
    ]
end

def $u'_state{#n} : Coin :=
    $0
    |> u3{2 * arccos(1 / sqrt(sqrt(2 ^ #n))), 0, 0}
    |> pmatch [
        $0 -> $Cdown;
        $1 -> $Cleft
    ]
end

def @as_leaf{#n} : Vertex{#n} -> Leaf{#n} :=
    if #n = 0 then
        lambda $Root'{0} -> ()
    else
        lambda @ListCons{#n + 1, Child}(x0, x) -> (x0, @as_leaf{#n - 1}(x))
    endif
end

def @left_child{#n} : Vertex{#n} -> Vertex{#n} :=
    lambda v -> @list_downcast{#n + 2, Child}(@ListCons{#n + 2, Child}($Vleft, v))
end

def @right_child{#n} : Vertex{#n} -> Vertex{#n} :=
    lambda v -> @list_downcast{#n + 2, Child}(@ListCons{#n + 2, Child}($Vright, v))
end

/*
If the current vertex is a leaf, apply the @f oracle. If it is an internal
vertex, reflect the coin over the $u_state, and if it is the $Root' vertex,
reflect the coin over the $u'_state.
*/
def @diffusion{#n, @f : Leaf{#n} -> Bit} : Coin * Vertex{#n} -> Coin * Vertex{#n} :=
    lambda (c, v) -> ctrl v [
        @ListCons{#n + 1, Child}(x', @ListCons{#n, Child}(x, v')) ->
            ctrl (
                try
                    @ListCons{#n + 1, Child}(x', @ListCons{#n, Child}(x, v'))
                    |> @as_leaf{#n} |> @Just{Leaf{#n}}
                catch
                    $Nothing{Leaf{#n}}
            ) [
                $Nothing{Leaf{#n}} -> (c |> @reflect{Coin, $u_state}, v);
                @Just{Leaf{#n}}(l) ->
                    ctrl @f(l) [
                        $0 -> (c, v);
                        $1 -> (c, v) |> gphase{pi}
                    ]
            ];
        $Root{#n} -> (c, v);
        else -> (c |> @reflect{Coin, $u'_state{#n}}, v); // Root'{#n}
    ]
end

/*
If current coin goes left or right, next coin is down. If current coin goes
down from left child, next coin is left, and if current coin goes down from
right child, next coin is right.
*/
def @next_coin{#n} : Coin * Vertex{#n} -> (Coin * Vertex{#n}) * Coin :=
    lambda x ->
        ctrl x [
            ($Cdown, @ListCons{#n + 1, Child}($Vleft, v)) -> (x, $Cleft);
            ($Cdown, @ListCons{#n + 1, Child}($Vright, v)) -> (x, $Cright);
            ($Cright, v) -> (x, $Cdown);
            ($Cleft, v) -> (x, $Cdown)
        ]
end

/*
Updates the vertex index according to the coin, and changes the coin,
effectively flipping the direction of the given edge.
*/
def @walk{#n} : Coin * Vertex{#n} -> Coin * Vertex{#n} :=
    lambda x ->
        x |> @next_coin{#n}
        |> lambda ((c, v), c') ->
            ctrl (c, c') [
                ($Cdown, $Cleft) ->
                    ((c', @adjoint{Vertex{#n}, Vertex{#n}, @left_child{#n}}(v)), c);
                ($Cdown, $Cright) ->
                    ((c', @adjoint{Vertex{#n}, Vertex{#n}, @right_child{#n}}(v)), c);
                ($Cleft, $Cdown) -> ((c', @left_child{#n}(v)), c);
                ($Cright, $Cdown) -> ((c', @right_child{#n}(v)), c)
            ]
        |> @adjoint{Coin * Vertex{#n}, (Coin * Vertex{#n}) * Coin, @next_coin{#n}}
end

def @run_quantum_walk{#n, @f : Leaf{#n} -> Bit, #n_iter} : Coin * Vertex{#n} -> Coin * Vertex{#n} :=
    if #n_iter = 0 then
        @id{Coin * Vertex{#n}}
    else
        lambda x ->
            x |> @diffusion{#n, @f} |> @walk{#n}
            |> @run_quantum_walk{#n, @f, #n_iter - 1}
    endif
end

def $initial_t_state{#t_bits} : Num{#t_bits} :=
    $repeated{#t_bits, Bit, $plus}
    |> rphase{($1, _), -pi / 2, 0}
    |>
    if #t_bits = 1 then
        @id{Num{#t_bits}}
    else
        rphase{(_0, ($1, _1)), pi, 0}
    endif
    |> @reverse{#t_bits, Bit}
end

/*
Given a #t_bits-bit register treg, applies the quantum walk t many times when
the register is in state t, coherently.
*/
def @controlled_walk{#t_bits, #n, @f : Leaf{#n} -> Bit} :
    Num{#t_bits} * (Coin * Vertex{#n}) -> Num{#t_bits} * (Coin * Vertex{#n}) :=
    if #t_bits = 0 then
        @id{Num{#t_bits} * (Coin * Vertex{#n})}
    else
        lambda ((t0, trest), (c, v)) ->
            ctrl t0 [
                $0 -> ((t0, trest), (c, v));
                $1 -> (
                    (t0, trest),
                    (c, v) |> @run_quantum_walk{#n, @f, 2 ^ (#t_bits - 1)}
                )
            ]
            |> lambda ((t0, trest), (c, v)) ->
                let (t0, (trest', (c', v'))) =
                (t0, (trest, (c, v)) |> @controlled_walk{#t_bits - 1, #n, @f})
                in ((t0, trest'), (c', v'))
    endif
end

/*
Perform phase estimation on the quantum walk using a register of #t_bits bits.
*/
def $quantum_walk_algorithm{#t_bits, #n, @f : Leaf{#n} -> Bit} : Bit :=
    ($initial_t_state{#t_bits}, ($Cleft, $Root{#n}))
    |> @controlled_walk{#t_bits, #n, @f}
    |> @fst{Num{#t_bits}, (Coin * Vertex{#n})}
    |> @adjoint{Num{#t_bits}, Num{#t_bits}, @qft{#t_bits}}
    |> lambda (x, x0) ->
        match x0 [
            $repeated{#t_bits - 1, Bit, $0} -> $0;
            else -> $1
        ]
end

def #t_bits := 2 end

def #n := 1 end

def @f : Leaf{#n} -> Bit :=
    lambda (c0, ()) -> $1
end

$quantum_walk_algorithm{#t_bits, #n, @f}
