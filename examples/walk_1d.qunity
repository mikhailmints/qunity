def @Step {#N} : Num{#N} * Bit -> Num{#N} * Bit :=
    lambda (x, velocity) ->
    match (x, velocity) [
        ($NTensorE {#N, Bit, $0}, $0) -> (@IncrementLE{#N}(x), @Not(velocity));
        ($NTensorE {#N, Bit, $1}, $1) -> (@DecrementLE{#N}(x), @Not(velocity));
        else -> match velocity [
            $0 -> (@DecrementLE{#N}(x), velocity);
            $1 -> (@IncrementLE{#N}(x), velocity)
        ]
    ]
end

def @Walk {#N, #Nsteps} : Num{#N} * Bit -> Num{#N} * Bit :=
    if #Nsteps = 0 then
        @Id{Num{#N} * Bit}
    else
        lambda (x, velocity) ->
        (x, velocity) |> @Step{#N} |> @Walk{#N, #Nsteps - 1}
    endif
end

def #N := 3 end
def #Nsteps := 1 end

($NTensorE {#N, Bit, $Plus}, $0 |> u3 {pi/4, 0, 0})
|> @Walk {#N, #Nsteps}
|> @Fst {Num{#N}, Bit}
|> @Reverse {#N, Bit}
