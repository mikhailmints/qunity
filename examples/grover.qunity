// A single Grover iteration for oracle F on N qubits
def GroverIter <N, F> :=
    lambda x {NTensorT <N, Bit>} ->
    // Apply F as a phase oracle
    ctrl {Bit, NTensorT <N, Bit>} (F of x) [
        Bit0 -> x;
        Bit1 -> x |> gphase {NTensorT <N, Bit>, pi}
    ] |>
    // Grover diffusion operator
    Reflect <NTensorT <N, Bit>, NTensorE <N, BitPlus>>
end

// Run Grover's algorithm for Niter iterations
def Grover <N, F, Niter> :=
    if Niter = [0] then
        NTensorE <N, BitPlus>
    else
        Grover <N, F, [Niter - 1]> |> GroverIter <N, F>
    endif
end

def N := [3] end
def Answer := (Bit0, (Bit1, (Bit0, ()))) end

// Quantum oracle representing a function acting on 3 bits that outputs
// 1 for the input 010 and 0 for other inputs
def F :=
    lambda x {NTensorT <N, Bit>} ->
    ctrl {NTensorT <N, Bit>, NTensorT <N, Bit> * Bit} x [
        Answer -> (x, Bit1);
        else -> (x, Bit0)
    ] |> Snd <NTensorT <N, Bit>, Bit>
end

Grover <N, F, [2]>

