def @Step {#N} : Num{#N} * Bit -> Num{#N} * Bit :=
    lambda (x, velocity) ->
    ctrl (match (x, velocity) [
        ($NTensorE {#N, Bit, $0}, $0) -> @Just{Bit}($0);
        ($NTensorE {#N, Bit, $1}, $1) -> @Just{Bit}($1);
        else -> $Nothing{Bit}
    ]) [
        @Just{Bit}($0) -> ((x, velocity), (@IncrementLE{#N}($NTensorE {#N, Bit, $0}), $1));
        @Just{Bit}($1) -> ((x, velocity), (@DecrementLE{#N}($NTensorE {#N, Bit, $1}), $0));
        $Nothing{Bit} -> ((x, velocity), ctrl velocity [
            $0 -> (@DecrementLE{#N}(x), velocity);
            $1 -> (@IncrementLE{#N}(x), velocity)
        ])
    ] |> @Snd {Num{#N} * Bit, Num{#N} * Bit}
end

def @Walk {#N, #Nsteps} : Num{#N} * Bit -> Num{#N} * Bit :=
    if #Nsteps = 0 then
        @Id{Num{#N} * Bit}
    else
        lambda (x, velocity) ->
        (x, velocity) |> @Step{#N} |> @Walk{#N, #Nsteps - 1}
    endif
end

def #N := 3 end
def #Nsteps := 1 end

($NTensorE {#N, Bit, $Plus}, $0 |> u3 {pi/4, 0, 0})
|> @Walk {#N, #Nsteps}
|> @Fst {Num{#N}, Bit}
|> @Reverse {#N, Bit}
