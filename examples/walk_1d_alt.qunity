def @Step {#N} : Num{#N} * Bit -> Num{#N} * Bit :=
    lambda (x, velocity) -> ctrl (x, velocity) [
        ($NTensorE {#N, Bit, $0}, $0) -> ((x, velocity), @Just{Bit}($0));
        ($NTensorE {#N, Bit, $1}, $1) -> ((x, velocity), @Just{Bit}($1));
        else -> ((x, velocity), $Nothing{Bit});
    ]
    |> lambda ((x, velocity), label) -> match label [
        @Just{Bit}($0) -> (@Increment{#N}(x), @Not(velocity));
        @Just{Bit}($1) -> (@Decrement{#N}(x), @Not(velocity));
        $Nothing{Bit} -> ctrl velocity [
            $0 -> (@Decrement{#N}(x), velocity);
            $1 -> (@Increment{#N}(x), velocity)
        ]
    ]
end

def @Walk {#N, #Nsteps} : Num{#N} * Bit -> Num{#N} * Bit :=
    if #Nsteps = 0 then
        @Id{Num{#N} * Bit}
    else
        lambda (x, velocity) ->
        (x, velocity) |> @Step{#N} |> @Walk{#N, #Nsteps - 1}
    endif
end

def #N := 3 end
def #Nsteps := 1 end

($NTensorE {#N, Bit, $Plus}, $0 |> u3 {pi/4, 0, 0})
|> @Walk {#N, #Nsteps}
|> @Fst {Num{#N}, Bit}
|> @Reverse {#N, Bit}
