qunityfile: VOID
##
## Ends in an error in state: 2.
##
## deflist -> deflist . definition [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR DEF CTRL ]
## qunityfile -> deflist . xexpr EOF [ # ]
##
## The known suffix of the stack is as follows:
## deflist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: U3 VOID
##
## Ends in an error in state: 3.
##
## xprog -> U3 . LBRACE xreal COMMA xreal COMMA xreal RBRACE [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## U3
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: U3 LBRACE VOID
##
## Ends in an error in state: 4.
##
## xprog -> U3 LBRACE . xreal COMMA xreal COMMA xreal RBRACE [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## U3 LBRACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF TAN VOID
##
## Ends in an error in state: 5.
##
## xreal -> TAN . LPAREN xreal RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## TAN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF TAN LPAREN VOID
##
## Ends in an error in state: 6.
##
## xreal -> TAN LPAREN . xreal RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## TAN LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF SQRT VOID
##
## Ends in an error in state: 7.
##
## xreal -> SQRT . LPAREN xreal RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## SQRT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF SQRT LPAREN VOID
##
## Ends in an error in state: 8.
##
## xreal -> SQRT LPAREN . xreal RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## SQRT LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF SIN VOID
##
## Ends in an error in state: 9.
##
## xreal -> SIN . LPAREN xreal RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## SIN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF SIN LPAREN VOID
##
## Ends in an error in state: 10.
##
## xreal -> SIN LPAREN . xreal RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## SIN LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF REALVAR VOID
##
## Ends in an error in state: 11.
##
## xreal -> REALVAR . arglist [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## REALVAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: EXPRVAR LBRACE VBAR
##
## Ends in an error in state: 12.
##
## arglist -> LBRACE . arglist_nonempty RBRACE [ VBAR TIMES THEN SEMICOLON RPAREN RBRACKET RBRACE POW PLUS PIPE OR NEQ MOD MINUS LT LPAREN LEQ LBRACKET IN GT GEQ EQUAL EOF ENDIF END ELSE DIV DEFSTART COMMA CATCH ARROW AND ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: EXPRVAR LBRACE TYPENAME VOID
##
## Ends in an error in state: 16.
##
## xtype -> TYPENAME . arglist [ VBAR TIMES RPAREN RBRACE ENDIF END ELSE DEFSTART COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## TYPENAME
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: TRY VOID
##
## Ends in an error in state: 18.
##
## xexpr -> TRY . xexpr CATCH xexpr [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## TRY
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: RPHASE VOID
##
## Ends in an error in state: 19.
##
## xprog -> RPHASE . LBRACE xexpr COMMA xreal COMMA xreal RBRACE [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## RPHASE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: RPHASE LBRACE VOID
##
## Ends in an error in state: 20.
##
## xprog -> RPHASE LBRACE . xexpr COMMA xreal COMMA xreal RBRACE [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## RPHASE LBRACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: PROGVAR VOID
##
## Ends in an error in state: 22.
##
## xprog -> PROGVAR . arglist [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## PROGVAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: PMATCH VOID
##
## Ends in an error in state: 24.
##
## xprog -> PMATCH . LBRACKET pmatchblock [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## PMATCH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: PMATCH LBRACKET VOID
##
## Ends in an error in state: 25.
##
## xprog -> PMATCH LBRACKET . pmatchblock [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## PMATCH LBRACKET
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: MATCH VOID
##
## Ends in an error in state: 28.
##
## xexpr -> MATCH . xexpr LBRACKET ctrlblock [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## MATCH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: LPAREN VOID
##
## Ends in an error in state: 29.
##
## xexpr -> LPAREN . xexpr COMMA xexpr RPAREN [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xexpr -> LPAREN . xexpr RPAREN [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xprog -> LPAREN . xprog RPAREN [ RPAREN LPAREN ELSE ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: LET VOID
##
## Ends in an error in state: 30.
##
## xexpr -> LET . xexpr EQUAL xexpr IN xexpr [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## LET
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: LAMBDA VOID
##
## Ends in an error in state: 31.
##
## xprog -> LAMBDA . xexpr ARROW xexpr [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## LAMBDA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF VOID
##
## Ends in an error in state: 32.
##
## xexpr -> IF . bexpr THEN xexpr ELSE xexpr ENDIF [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xprog -> IF . bexpr THEN xprog ELSE xprog ENDIF [ RPAREN LPAREN ELSE ]
##
## The known suffix of the stack is as follows:
## IF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF NOT VOID
##
## Ends in an error in state: 34.
##
## bexpr -> NOT . bexpr [ THEN RPAREN OR AND ]
##
## The known suffix of the stack is as follows:
## NOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF MINUS VOID
##
## Ends in an error in state: 35.
##
## xreal -> MINUS . xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## MINUS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: GPHASE LBRACE LPAREN VOID
##
## Ends in an error in state: 36.
##
## xreal -> LPAREN . xreal RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF LOG2 VOID
##
## Ends in an error in state: 37.
##
## xreal -> LOG2 . LPAREN xreal RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## LOG2
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF LOG2 LPAREN VOID
##
## Ends in an error in state: 38.
##
## xreal -> LOG2 LPAREN . xreal RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## LOG2 LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF LN VOID
##
## Ends in an error in state: 39.
##
## xreal -> LN . LPAREN xreal RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## LN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF LN LPAREN VOID
##
## Ends in an error in state: 40.
##
## xreal -> LN LPAREN . xreal RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## LN LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF IF VOID
##
## Ends in an error in state: 41.
##
## xreal -> IF . bexpr THEN xreal ELSE xreal ENDIF [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## IF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF LPAREN VOID
##
## Ends in an error in state: 42.
##
## bexpr -> LPAREN . bexpr RPAREN [ THEN RPAREN OR AND ]
## xreal -> LPAREN . xreal RPAREN [ TIMES RPAREN POW PLUS NEQ MOD MINUS LT LEQ GT GEQ EQUAL DIV ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF FLOOR VOID
##
## Ends in an error in state: 43.
##
## xreal -> FLOOR . LPAREN xreal RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## FLOOR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF FLOOR LPAREN VOID
##
## Ends in an error in state: 44.
##
## xreal -> FLOOR LPAREN . xreal RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## FLOOR LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF EXP VOID
##
## Ends in an error in state: 45.
##
## xreal -> EXP . LPAREN xreal RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## EXP
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF EXP LPAREN VOID
##
## Ends in an error in state: 46.
##
## xreal -> EXP LPAREN . xreal RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## EXP LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF COS VOID
##
## Ends in an error in state: 48.
##
## xreal -> COS . LPAREN xreal RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## COS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF COS LPAREN VOID
##
## Ends in an error in state: 49.
##
## xreal -> COS LPAREN . xreal RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## COS LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF CEIL VOID
##
## Ends in an error in state: 51.
##
## xreal -> CEIL . LPAREN xreal RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## CEIL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF CEIL LPAREN VOID
##
## Ends in an error in state: 52.
##
## xreal -> CEIL LPAREN . xreal RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## CEIL LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF ARCTAN VOID
##
## Ends in an error in state: 53.
##
## xreal -> ARCTAN . LPAREN xreal RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## ARCTAN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF ARCTAN LPAREN VOID
##
## Ends in an error in state: 54.
##
## xreal -> ARCTAN LPAREN . xreal RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## ARCTAN LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF ARCSIN VOID
##
## Ends in an error in state: 55.
##
## xreal -> ARCSIN . LPAREN xreal RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## ARCSIN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF ARCSIN LPAREN VOID
##
## Ends in an error in state: 56.
##
## xreal -> ARCSIN LPAREN . xreal RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## ARCSIN LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF ARCCOS VOID
##
## Ends in an error in state: 57.
##
## xreal -> ARCCOS . LPAREN xreal RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## ARCCOS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF ARCCOS LPAREN VOID
##
## Ends in an error in state: 58.
##
## xreal -> ARCCOS LPAREN . xreal RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## ARCCOS LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF ARCCOS LPAREN REALVAR THEN
##
## Ends in an error in state: 59.
##
## xreal -> xreal . PLUS xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . TIMES xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MINUS xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . DIV xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . POW xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MOD xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> ARCCOS LPAREN xreal . RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## ARCCOS LPAREN xreal
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF REALVAR TIMES VOID
##
## Ends in an error in state: 60.
##
## xreal -> xreal TIMES . xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## xreal TIMES
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF REALVAR TIMES CONST VOID
##
## Ends in an error in state: 61.
##
## xreal -> xreal . PLUS xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . TIMES xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal TIMES xreal . [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . MINUS xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . DIV xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . POW xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . MOD xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## xreal TIMES xreal
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF REALVAR POW VOID
##
## Ends in an error in state: 62.
##
## xreal -> xreal POW . xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## xreal POW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF REALVAR POW CONST VOID
##
## Ends in an error in state: 63.
##
## xreal -> xreal . PLUS xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . TIMES xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . MINUS xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . DIV xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . POW xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal POW xreal . [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . MOD xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## xreal POW xreal
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF REALVAR MOD VOID
##
## Ends in an error in state: 64.
##
## xreal -> xreal MOD . xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## xreal MOD
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF REALVAR MOD CONST VOID
##
## Ends in an error in state: 65.
##
## xreal -> xreal . PLUS xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . TIMES xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . MINUS xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . DIV xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . POW xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . MOD xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal MOD xreal . [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## xreal MOD xreal
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF REALVAR DIV VOID
##
## Ends in an error in state: 66.
##
## xreal -> xreal DIV . xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## xreal DIV
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF REALVAR DIV CONST VOID
##
## Ends in an error in state: 67.
##
## xreal -> xreal . PLUS xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . TIMES xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . MINUS xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . DIV xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal DIV xreal . [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . POW xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . MOD xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## xreal DIV xreal
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF REALVAR PLUS VOID
##
## Ends in an error in state: 69.
##
## xreal -> xreal PLUS . xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## xreal PLUS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF REALVAR PLUS CONST VOID
##
## Ends in an error in state: 70.
##
## xreal -> xreal . PLUS xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal PLUS xreal . [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . TIMES xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . MINUS xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . DIV xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . POW xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . MOD xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## xreal PLUS xreal
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF REALVAR MINUS VOID
##
## Ends in an error in state: 71.
##
## xreal -> xreal MINUS . xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## xreal MINUS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF REALVAR MINUS CONST VOID
##
## Ends in an error in state: 72.
##
## xreal -> xreal . PLUS xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . TIMES xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . MINUS xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal MINUS xreal . [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . DIV xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . POW xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . MOD xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## xreal MINUS xreal
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF ARCSIN LPAREN REALVAR THEN
##
## Ends in an error in state: 73.
##
## xreal -> xreal . PLUS xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . TIMES xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MINUS xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . DIV xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . POW xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MOD xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> ARCSIN LPAREN xreal . RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## ARCSIN LPAREN xreal
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF ARCTAN LPAREN REALVAR THEN
##
## Ends in an error in state: 75.
##
## xreal -> xreal . PLUS xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . TIMES xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MINUS xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . DIV xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . POW xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MOD xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> ARCTAN LPAREN xreal . RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## ARCTAN LPAREN xreal
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF CEIL LPAREN REALVAR THEN
##
## Ends in an error in state: 77.
##
## xreal -> xreal . PLUS xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . TIMES xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MINUS xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . DIV xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . POW xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MOD xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> CEIL LPAREN xreal . RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## CEIL LPAREN xreal
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF COS LPAREN REALVAR THEN
##
## Ends in an error in state: 79.
##
## xreal -> xreal . PLUS xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . TIMES xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MINUS xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . DIV xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . POW xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MOD xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> COS LPAREN xreal . RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## COS LPAREN xreal
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF EXP LPAREN REALVAR THEN
##
## Ends in an error in state: 81.
##
## xreal -> xreal . PLUS xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . TIMES xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MINUS xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . DIV xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . POW xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MOD xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> EXP LPAREN xreal . RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## EXP LPAREN xreal
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF FLOOR LPAREN REALVAR THEN
##
## Ends in an error in state: 83.
##
## xreal -> xreal . PLUS xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . TIMES xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MINUS xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . DIV xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . POW xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MOD xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> FLOOR LPAREN xreal . RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## FLOOR LPAREN xreal
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF LPAREN REALVAR THEN
##
## Ends in an error in state: 85.
##
## bexpr -> xreal . comparison xreal [ RPAREN OR AND ]
## xreal -> xreal . PLUS xreal [ TIMES RPAREN POW PLUS NEQ MOD MINUS LT LEQ GT GEQ EQUAL DIV ]
## xreal -> xreal . TIMES xreal [ TIMES RPAREN POW PLUS NEQ MOD MINUS LT LEQ GT GEQ EQUAL DIV ]
## xreal -> xreal . MINUS xreal [ TIMES RPAREN POW PLUS NEQ MOD MINUS LT LEQ GT GEQ EQUAL DIV ]
## xreal -> xreal . DIV xreal [ TIMES RPAREN POW PLUS NEQ MOD MINUS LT LEQ GT GEQ EQUAL DIV ]
## xreal -> xreal . POW xreal [ TIMES RPAREN POW PLUS NEQ MOD MINUS LT LEQ GT GEQ EQUAL DIV ]
## xreal -> xreal . MOD xreal [ TIMES RPAREN POW PLUS NEQ MOD MINUS LT LEQ GT GEQ EQUAL DIV ]
## xreal -> LPAREN xreal . RPAREN [ TIMES RPAREN POW PLUS NEQ MOD MINUS LT LEQ GT GEQ EQUAL DIV ]
##
## The known suffix of the stack is as follows:
## LPAREN xreal
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF REALVAR EQUAL VOID
##
## Ends in an error in state: 93.
##
## bexpr -> xreal comparison . xreal [ THEN RPAREN OR AND ]
##
## The known suffix of the stack is as follows:
## xreal comparison
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF REALVAR EQUAL REALVAR RBRACE
##
## Ends in an error in state: 94.
##
## bexpr -> xreal comparison xreal . [ THEN RPAREN OR AND ]
## xreal -> xreal . PLUS xreal [ TIMES THEN RPAREN POW PLUS OR MOD MINUS DIV AND ]
## xreal -> xreal . TIMES xreal [ TIMES THEN RPAREN POW PLUS OR MOD MINUS DIV AND ]
## xreal -> xreal . MINUS xreal [ TIMES THEN RPAREN POW PLUS OR MOD MINUS DIV AND ]
## xreal -> xreal . DIV xreal [ TIMES THEN RPAREN POW PLUS OR MOD MINUS DIV AND ]
## xreal -> xreal . POW xreal [ TIMES THEN RPAREN POW PLUS OR MOD MINUS DIV AND ]
## xreal -> xreal . MOD xreal [ TIMES THEN RPAREN POW PLUS OR MOD MINUS DIV AND ]
##
## The known suffix of the stack is as follows:
## xreal comparison xreal
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF LPAREN REALVAR EQUAL REALVAR THEN
##
## Ends in an error in state: 95.
##
## bexpr -> bexpr . AND bexpr [ RPAREN OR AND ]
## bexpr -> bexpr . OR bexpr [ RPAREN OR AND ]
## bexpr -> LPAREN bexpr . RPAREN [ THEN RPAREN OR AND ]
##
## The known suffix of the stack is as follows:
## LPAREN bexpr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
## In state 94, spurious reduction of production bexpr -> xreal comparison xreal
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF REALVAR EQUAL REALVAR OR VOID
##
## Ends in an error in state: 97.
##
## bexpr -> bexpr OR . bexpr [ THEN RPAREN OR AND ]
##
## The known suffix of the stack is as follows:
## bexpr OR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF REALVAR THEN
##
## Ends in an error in state: 98.
##
## bexpr -> xreal . comparison xreal [ THEN RPAREN OR AND ]
## xreal -> xreal . PLUS xreal [ TIMES POW PLUS NEQ MOD MINUS LT LEQ GT GEQ EQUAL DIV ]
## xreal -> xreal . TIMES xreal [ TIMES POW PLUS NEQ MOD MINUS LT LEQ GT GEQ EQUAL DIV ]
## xreal -> xreal . MINUS xreal [ TIMES POW PLUS NEQ MOD MINUS LT LEQ GT GEQ EQUAL DIV ]
## xreal -> xreal . DIV xreal [ TIMES POW PLUS NEQ MOD MINUS LT LEQ GT GEQ EQUAL DIV ]
## xreal -> xreal . POW xreal [ TIMES POW PLUS NEQ MOD MINUS LT LEQ GT GEQ EQUAL DIV ]
## xreal -> xreal . MOD xreal [ TIMES POW PLUS NEQ MOD MINUS LT LEQ GT GEQ EQUAL DIV ]
##
## The known suffix of the stack is as follows:
## xreal
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF REALVAR EQUAL REALVAR AND VOID
##
## Ends in an error in state: 100.
##
## bexpr -> bexpr AND . bexpr [ THEN RPAREN OR AND ]
##
## The known suffix of the stack is as follows:
## bexpr AND
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF REALVAR EQUAL REALVAR AND LPAREN REALVAR EQUAL REALVAR RPAREN VOID
##
## Ends in an error in state: 101.
##
## bexpr -> bexpr . AND bexpr [ THEN RPAREN OR AND ]
## bexpr -> bexpr AND bexpr . [ THEN RPAREN OR AND ]
## bexpr -> bexpr . OR bexpr [ THEN RPAREN OR AND ]
##
## The known suffix of the stack is as follows:
## bexpr AND bexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF IF REALVAR EQUAL REALVAR RPAREN
##
## Ends in an error in state: 102.
##
## bexpr -> bexpr . AND bexpr [ THEN OR AND ]
## bexpr -> bexpr . OR bexpr [ THEN OR AND ]
## xreal -> IF bexpr . THEN xreal ELSE xreal ENDIF [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## IF bexpr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
## In state 94, spurious reduction of production bexpr -> xreal comparison xreal
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF IF REALVAR EQUAL REALVAR THEN VOID
##
## Ends in an error in state: 103.
##
## xreal -> IF bexpr THEN . xreal ELSE xreal ENDIF [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## IF bexpr THEN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF IF REALVAR EQUAL REALVAR THEN REALVAR THEN
##
## Ends in an error in state: 104.
##
## xreal -> xreal . PLUS xreal [ TIMES POW PLUS MOD MINUS ELSE DIV ]
## xreal -> xreal . TIMES xreal [ TIMES POW PLUS MOD MINUS ELSE DIV ]
## xreal -> xreal . MINUS xreal [ TIMES POW PLUS MOD MINUS ELSE DIV ]
## xreal -> xreal . DIV xreal [ TIMES POW PLUS MOD MINUS ELSE DIV ]
## xreal -> xreal . POW xreal [ TIMES POW PLUS MOD MINUS ELSE DIV ]
## xreal -> xreal . MOD xreal [ TIMES POW PLUS MOD MINUS ELSE DIV ]
## xreal -> IF bexpr THEN xreal . ELSE xreal ENDIF [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## IF bexpr THEN xreal
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF IF REALVAR EQUAL REALVAR THEN REALVAR ELSE VOID
##
## Ends in an error in state: 105.
##
## xreal -> IF bexpr THEN xreal ELSE . xreal ENDIF [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## IF bexpr THEN xreal ELSE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF IF REALVAR EQUAL REALVAR THEN REALVAR ELSE REALVAR THEN
##
## Ends in an error in state: 106.
##
## xreal -> xreal . PLUS xreal [ TIMES POW PLUS MOD MINUS ENDIF DIV ]
## xreal -> xreal . TIMES xreal [ TIMES POW PLUS MOD MINUS ENDIF DIV ]
## xreal -> xreal . MINUS xreal [ TIMES POW PLUS MOD MINUS ENDIF DIV ]
## xreal -> xreal . DIV xreal [ TIMES POW PLUS MOD MINUS ENDIF DIV ]
## xreal -> xreal . POW xreal [ TIMES POW PLUS MOD MINUS ENDIF DIV ]
## xreal -> xreal . MOD xreal [ TIMES POW PLUS MOD MINUS ENDIF DIV ]
## xreal -> IF bexpr THEN xreal ELSE xreal . ENDIF [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## IF bexpr THEN xreal ELSE xreal
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF LN LPAREN REALVAR THEN
##
## Ends in an error in state: 108.
##
## xreal -> xreal . PLUS xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . TIMES xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MINUS xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . DIV xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . POW xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MOD xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> LN LPAREN xreal . RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## LN LPAREN xreal
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF LOG2 LPAREN REALVAR THEN
##
## Ends in an error in state: 110.
##
## xreal -> xreal . PLUS xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . TIMES xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MINUS xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . DIV xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . POW xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MOD xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> LOG2 LPAREN xreal . RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## LOG2 LPAREN xreal
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: EXPRVAR LBRACE LPAREN REALVAR THEN
##
## Ends in an error in state: 112.
##
## xreal -> xreal . PLUS xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . TIMES xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MINUS xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . DIV xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . POW xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MOD xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> LPAREN xreal . RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## LPAREN xreal
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF MINUS CONST VOID
##
## Ends in an error in state: 113.
##
## xreal -> MINUS xreal . [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . PLUS xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . TIMES xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . MINUS xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . DIV xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . POW xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
## xreal -> xreal . MOD xreal [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## MINUS xreal
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF NOT LPAREN REALVAR EQUAL REALVAR RPAREN VOID
##
## Ends in an error in state: 114.
##
## bexpr -> NOT bexpr . [ THEN RPAREN OR AND ]
## bexpr -> bexpr . AND bexpr [ THEN RPAREN OR AND ]
## bexpr -> bexpr . OR bexpr [ THEN RPAREN OR AND ]
##
## The known suffix of the stack is as follows:
## NOT bexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF REALVAR EQUAL REALVAR RPAREN
##
## Ends in an error in state: 115.
##
## bexpr -> bexpr . AND bexpr [ THEN OR AND ]
## bexpr -> bexpr . OR bexpr [ THEN OR AND ]
## xexpr -> IF bexpr . THEN xexpr ELSE xexpr ENDIF [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xprog -> IF bexpr . THEN xprog ELSE xprog ENDIF [ RPAREN LPAREN ELSE ]
##
## The known suffix of the stack is as follows:
## IF bexpr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
## In state 94, spurious reduction of production bexpr -> xreal comparison xreal
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF REALVAR EQUAL REALVAR THEN VOID
##
## Ends in an error in state: 116.
##
## xexpr -> IF bexpr THEN . xexpr ELSE xexpr ENDIF [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xprog -> IF bexpr THEN . xprog ELSE xprog ENDIF [ RPAREN LPAREN ELSE ]
##
## The known suffix of the stack is as follows:
## IF bexpr THEN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: GPHASE VOID
##
## Ends in an error in state: 117.
##
## xprog -> GPHASE . LBRACE xreal RBRACE [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## GPHASE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: GPHASE LBRACE VOID
##
## Ends in an error in state: 118.
##
## xprog -> GPHASE LBRACE . xreal RBRACE [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## GPHASE LBRACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: GPHASE LBRACE REALVAR THEN
##
## Ends in an error in state: 119.
##
## xprog -> GPHASE LBRACE xreal . RBRACE [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xreal -> xreal . PLUS xreal [ TIMES RBRACE POW PLUS MOD MINUS DIV ]
## xreal -> xreal . TIMES xreal [ TIMES RBRACE POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MINUS xreal [ TIMES RBRACE POW PLUS MOD MINUS DIV ]
## xreal -> xreal . DIV xreal [ TIMES RBRACE POW PLUS MOD MINUS DIV ]
## xreal -> xreal . POW xreal [ TIMES RBRACE POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MOD xreal [ TIMES RBRACE POW PLUS MOD MINUS DIV ]
##
## The known suffix of the stack is as follows:
## GPHASE LBRACE xreal
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: EXPRVAR VOID
##
## Ends in an error in state: 121.
##
## xexpr -> EXPRVAR . arglist [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## EXPRVAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: CTRL VOID
##
## Ends in an error in state: 123.
##
## xexpr -> CTRL . xexpr LBRACKET ctrlblock [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## CTRL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: PROGVAR SEMICOLON
##
## Ends in an error in state: 124.
##
## xexpr -> xprog . LPAREN xexpr RPAREN [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xexpr -> xprog . LPAREN xexpr COMMA xexpr RPAREN [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## xprog
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 22, spurious reduction of production arglist ->
## In state 23, spurious reduction of production xprog -> PROGVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: PROGVAR LPAREN VOID
##
## Ends in an error in state: 125.
##
## xexpr -> xprog LPAREN . xexpr RPAREN [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xexpr -> xprog LPAREN . xexpr COMMA xexpr RPAREN [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## xprog LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: PROGVAR LPAREN NULL VOID
##
## Ends in an error in state: 126.
##
## xexpr -> xprog LPAREN xexpr . RPAREN [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xexpr -> xprog LPAREN xexpr . COMMA xexpr RPAREN [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xexpr -> xexpr . PIPE xprog [ RPAREN PIPE COMMA ]
##
## The known suffix of the stack is as follows:
## xprog LPAREN xexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: EXPRVAR PIPE VOID
##
## Ends in an error in state: 128.
##
## xexpr -> xexpr PIPE . xprog [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## xexpr PIPE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: EXPRVAR PIPE LPAREN VOID
##
## Ends in an error in state: 129.
##
## xprog -> LPAREN . xprog RPAREN [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: EXPRVAR PIPE IF VOID
##
## Ends in an error in state: 130.
##
## xprog -> IF . bexpr THEN xprog ELSE xprog ENDIF [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## IF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: EXPRVAR PIPE IF REALVAR EQUAL REALVAR RPAREN
##
## Ends in an error in state: 131.
##
## bexpr -> bexpr . AND bexpr [ THEN OR AND ]
## bexpr -> bexpr . OR bexpr [ THEN OR AND ]
## xprog -> IF bexpr . THEN xprog ELSE xprog ENDIF [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## IF bexpr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
## In state 94, spurious reduction of production bexpr -> xreal comparison xreal
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: EXPRVAR PIPE IF REALVAR EQUAL REALVAR THEN VOID
##
## Ends in an error in state: 132.
##
## xprog -> IF bexpr THEN . xprog ELSE xprog ENDIF [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## IF bexpr THEN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: EXPRVAR PIPE IF REALVAR EQUAL REALVAR THEN PROGVAR SEMICOLON
##
## Ends in an error in state: 133.
##
## xprog -> IF bexpr THEN xprog . ELSE xprog ENDIF [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## IF bexpr THEN xprog
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 22, spurious reduction of production arglist ->
## In state 23, spurious reduction of production xprog -> PROGVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF REALVAR EQUAL REALVAR THEN PROGVAR ELSE VOID
##
## Ends in an error in state: 134.
##
## xprog -> IF bexpr THEN xprog ELSE . xprog ENDIF [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## IF bexpr THEN xprog ELSE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF REALVAR EQUAL REALVAR THEN PROGVAR ELSE PROGVAR SEMICOLON
##
## Ends in an error in state: 135.
##
## xprog -> IF bexpr THEN xprog ELSE xprog . ENDIF [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## IF bexpr THEN xprog ELSE xprog
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 22, spurious reduction of production arglist ->
## In state 23, spurious reduction of production xprog -> PROGVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: EXPRVAR PIPE LPAREN PROGVAR SEMICOLON
##
## Ends in an error in state: 137.
##
## xprog -> LPAREN xprog . RPAREN [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## LPAREN xprog
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 22, spurious reduction of production arglist ->
## In state 23, spurious reduction of production xprog -> PROGVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: PROGVAR LPAREN EXPRVAR COMMA VOID
##
## Ends in an error in state: 140.
##
## xexpr -> xprog LPAREN xexpr COMMA . xexpr RPAREN [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## xprog LPAREN xexpr COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: PROGVAR LPAREN EXPRVAR COMMA NULL VOID
##
## Ends in an error in state: 141.
##
## xexpr -> xprog LPAREN xexpr COMMA xexpr . RPAREN [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xexpr -> xexpr . PIPE xprog [ RPAREN PIPE ]
##
## The known suffix of the stack is as follows:
## xprog LPAREN xexpr COMMA xexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: CTRL NULL VOID
##
## Ends in an error in state: 143.
##
## xexpr -> CTRL xexpr . LBRACKET ctrlblock [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xexpr -> xexpr . PIPE xprog [ PIPE LBRACKET ]
##
## The known suffix of the stack is as follows:
## CTRL xexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: CTRL EXPRVAR LBRACKET VOID
##
## Ends in an error in state: 144.
##
## xexpr -> CTRL xexpr LBRACKET . ctrlblock [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## CTRL xexpr LBRACKET
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: CTRL EXPRVAR LBRACKET NULL VOID
##
## Ends in an error in state: 146.
##
## ctrlblock -> xexpr . ARROW xexpr SEMICOLON ctrlblock [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## ctrlblock -> xexpr . ARROW xexpr RBRACKET [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## ctrlblock -> xexpr . ARROW xexpr SEMICOLON ELSE ARROW xexpr RBRACKET [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## ctrlblock -> xexpr . ARROW xexpr SEMICOLON ELSE ARROW xexpr SEMICOLON RBRACKET [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xexpr -> xexpr . PIPE xprog [ PIPE ARROW ]
##
## The known suffix of the stack is as follows:
## xexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: CTRL EXPRVAR LBRACKET EXPRVAR ARROW VOID
##
## Ends in an error in state: 147.
##
## ctrlblock -> xexpr ARROW . xexpr SEMICOLON ctrlblock [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## ctrlblock -> xexpr ARROW . xexpr RBRACKET [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## ctrlblock -> xexpr ARROW . xexpr SEMICOLON ELSE ARROW xexpr RBRACKET [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## ctrlblock -> xexpr ARROW . xexpr SEMICOLON ELSE ARROW xexpr SEMICOLON RBRACKET [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## xexpr ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: CTRL EXPRVAR LBRACKET EXPRVAR ARROW NULL VOID
##
## Ends in an error in state: 148.
##
## ctrlblock -> xexpr ARROW xexpr . SEMICOLON ctrlblock [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## ctrlblock -> xexpr ARROW xexpr . RBRACKET [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## ctrlblock -> xexpr ARROW xexpr . SEMICOLON ELSE ARROW xexpr RBRACKET [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## ctrlblock -> xexpr ARROW xexpr . SEMICOLON ELSE ARROW xexpr SEMICOLON RBRACKET [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xexpr -> xexpr . PIPE xprog [ SEMICOLON RBRACKET PIPE ]
##
## The known suffix of the stack is as follows:
## xexpr ARROW xexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: CTRL EXPRVAR LBRACKET EXPRVAR ARROW EXPRVAR SEMICOLON VOID
##
## Ends in an error in state: 149.
##
## ctrlblock -> xexpr ARROW xexpr SEMICOLON . ctrlblock [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## ctrlblock -> xexpr ARROW xexpr SEMICOLON . ELSE ARROW xexpr RBRACKET [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## ctrlblock -> xexpr ARROW xexpr SEMICOLON . ELSE ARROW xexpr SEMICOLON RBRACKET [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## xexpr ARROW xexpr SEMICOLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: CTRL EXPRVAR LBRACKET EXPRVAR ARROW EXPRVAR SEMICOLON ELSE VOID
##
## Ends in an error in state: 150.
##
## ctrlblock -> xexpr ARROW xexpr SEMICOLON ELSE . ARROW xexpr RBRACKET [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## ctrlblock -> xexpr ARROW xexpr SEMICOLON ELSE . ARROW xexpr SEMICOLON RBRACKET [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## xexpr ARROW xexpr SEMICOLON ELSE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: CTRL EXPRVAR LBRACKET EXPRVAR ARROW EXPRVAR SEMICOLON ELSE ARROW VOID
##
## Ends in an error in state: 151.
##
## ctrlblock -> xexpr ARROW xexpr SEMICOLON ELSE ARROW . xexpr RBRACKET [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## ctrlblock -> xexpr ARROW xexpr SEMICOLON ELSE ARROW . xexpr SEMICOLON RBRACKET [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## xexpr ARROW xexpr SEMICOLON ELSE ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: CTRL EXPRVAR LBRACKET EXPRVAR ARROW EXPRVAR SEMICOLON ELSE ARROW NULL VOID
##
## Ends in an error in state: 152.
##
## ctrlblock -> xexpr ARROW xexpr SEMICOLON ELSE ARROW xexpr . RBRACKET [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## ctrlblock -> xexpr ARROW xexpr SEMICOLON ELSE ARROW xexpr . SEMICOLON RBRACKET [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xexpr -> xexpr . PIPE xprog [ SEMICOLON RBRACKET PIPE ]
##
## The known suffix of the stack is as follows:
## xexpr ARROW xexpr SEMICOLON ELSE ARROW xexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: CTRL EXPRVAR LBRACKET EXPRVAR ARROW EXPRVAR SEMICOLON ELSE ARROW EXPRVAR SEMICOLON VOID
##
## Ends in an error in state: 153.
##
## ctrlblock -> xexpr ARROW xexpr SEMICOLON ELSE ARROW xexpr SEMICOLON . RBRACKET [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## xexpr ARROW xexpr SEMICOLON ELSE ARROW xexpr SEMICOLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF REALVAR EQUAL REALVAR THEN PROGVAR SEMICOLON
##
## Ends in an error in state: 159.
##
## xexpr -> xprog . LPAREN xexpr RPAREN [ PIPE ELSE ]
## xexpr -> xprog . LPAREN xexpr COMMA xexpr RPAREN [ PIPE ELSE ]
## xprog -> IF bexpr THEN xprog . ELSE xprog ENDIF [ RPAREN RBRACE LPAREN ELSE COMMA ]
##
## The known suffix of the stack is as follows:
## IF bexpr THEN xprog
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 22, spurious reduction of production arglist ->
## In state 23, spurious reduction of production xprog -> PROGVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF REALVAR EQUAL REALVAR THEN NULL VOID
##
## Ends in an error in state: 160.
##
## xexpr -> xexpr . PIPE xprog [ PIPE ELSE ]
## xexpr -> IF bexpr THEN xexpr . ELSE xexpr ENDIF [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## IF bexpr THEN xexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF REALVAR EQUAL REALVAR THEN EXPRVAR ELSE VOID
##
## Ends in an error in state: 161.
##
## xexpr -> IF bexpr THEN xexpr ELSE . xexpr ENDIF [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## IF bexpr THEN xexpr ELSE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF REALVAR EQUAL REALVAR THEN EXPRVAR ELSE NULL VOID
##
## Ends in an error in state: 162.
##
## xexpr -> xexpr . PIPE xprog [ PIPE ENDIF ]
## xexpr -> IF bexpr THEN xexpr ELSE xexpr . ENDIF [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## IF bexpr THEN xexpr ELSE xexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: LAMBDA NULL VOID
##
## Ends in an error in state: 164.
##
## xexpr -> xexpr . PIPE xprog [ PIPE ARROW ]
## xprog -> LAMBDA xexpr . ARROW xexpr [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## LAMBDA xexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: LAMBDA EXPRVAR ARROW VOID
##
## Ends in an error in state: 165.
##
## xprog -> LAMBDA xexpr ARROW . xexpr [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## LAMBDA xexpr ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: LAMBDA EXPRVAR ARROW NULL VOID
##
## Ends in an error in state: 166.
##
## xexpr -> xexpr . PIPE xprog [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xprog -> LAMBDA xexpr ARROW xexpr . [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## LAMBDA xexpr ARROW xexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: LET NULL VOID
##
## Ends in an error in state: 167.
##
## xexpr -> xexpr . PIPE xprog [ PIPE EQUAL ]
## xexpr -> LET xexpr . EQUAL xexpr IN xexpr [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## LET xexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: LET EXPRVAR EQUAL VOID
##
## Ends in an error in state: 168.
##
## xexpr -> LET xexpr EQUAL . xexpr IN xexpr [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## LET xexpr EQUAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: LET EXPRVAR EQUAL NULL VOID
##
## Ends in an error in state: 169.
##
## xexpr -> xexpr . PIPE xprog [ PIPE IN ]
## xexpr -> LET xexpr EQUAL xexpr . IN xexpr [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## LET xexpr EQUAL xexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: LET EXPRVAR EQUAL EXPRVAR IN VOID
##
## Ends in an error in state: 170.
##
## xexpr -> LET xexpr EQUAL xexpr IN . xexpr [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## LET xexpr EQUAL xexpr IN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: LET EXPRVAR EQUAL EXPRVAR IN NULL VOID
##
## Ends in an error in state: 171.
##
## xexpr -> xexpr . PIPE xprog [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xexpr -> LET xexpr EQUAL xexpr IN xexpr . [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## LET xexpr EQUAL xexpr IN xexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: LPAREN PROGVAR SEMICOLON
##
## Ends in an error in state: 172.
##
## xexpr -> xprog . LPAREN xexpr RPAREN [ RPAREN PIPE COMMA ]
## xexpr -> xprog . LPAREN xexpr COMMA xexpr RPAREN [ RPAREN PIPE COMMA ]
## xprog -> LPAREN xprog . RPAREN [ RPAREN RBRACE LPAREN ELSE COMMA ]
##
## The known suffix of the stack is as follows:
## LPAREN xprog
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 22, spurious reduction of production arglist ->
## In state 23, spurious reduction of production xprog -> PROGVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: LPAREN NULL VOID
##
## Ends in an error in state: 173.
##
## xexpr -> LPAREN xexpr . COMMA xexpr RPAREN [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xexpr -> xexpr . PIPE xprog [ RPAREN PIPE COMMA ]
## xexpr -> LPAREN xexpr . RPAREN [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## LPAREN xexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: LPAREN EXPRVAR COMMA VOID
##
## Ends in an error in state: 175.
##
## xexpr -> LPAREN xexpr COMMA . xexpr RPAREN [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## LPAREN xexpr COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: LPAREN EXPRVAR COMMA NULL VOID
##
## Ends in an error in state: 176.
##
## xexpr -> LPAREN xexpr COMMA xexpr . RPAREN [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xexpr -> xexpr . PIPE xprog [ RPAREN PIPE ]
##
## The known suffix of the stack is as follows:
## LPAREN xexpr COMMA xexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: MATCH NULL VOID
##
## Ends in an error in state: 178.
##
## xexpr -> MATCH xexpr . LBRACKET ctrlblock [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xexpr -> xexpr . PIPE xprog [ PIPE LBRACKET ]
##
## The known suffix of the stack is as follows:
## MATCH xexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: MATCH EXPRVAR LBRACKET VOID
##
## Ends in an error in state: 179.
##
## xexpr -> MATCH xexpr LBRACKET . ctrlblock [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## MATCH xexpr LBRACKET
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: PMATCH LBRACKET NULL VOID
##
## Ends in an error in state: 181.
##
## pmatchblock -> xexpr . ARROW xexpr SEMICOLON pmatchblock [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## pmatchblock -> xexpr . ARROW xexpr RBRACKET [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xexpr -> xexpr . PIPE xprog [ PIPE ARROW ]
##
## The known suffix of the stack is as follows:
## xexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: PMATCH LBRACKET EXPRVAR ARROW VOID
##
## Ends in an error in state: 182.
##
## pmatchblock -> xexpr ARROW . xexpr SEMICOLON pmatchblock [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## pmatchblock -> xexpr ARROW . xexpr RBRACKET [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## xexpr ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: PMATCH LBRACKET EXPRVAR ARROW NULL VOID
##
## Ends in an error in state: 183.
##
## pmatchblock -> xexpr ARROW xexpr . SEMICOLON pmatchblock [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## pmatchblock -> xexpr ARROW xexpr . RBRACKET [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xexpr -> xexpr . PIPE xprog [ SEMICOLON RBRACKET PIPE ]
##
## The known suffix of the stack is as follows:
## xexpr ARROW xexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: PMATCH LBRACKET EXPRVAR ARROW EXPRVAR SEMICOLON VOID
##
## Ends in an error in state: 184.
##
## pmatchblock -> xexpr ARROW xexpr SEMICOLON . pmatchblock [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## xexpr ARROW xexpr SEMICOLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: RPHASE LBRACE NULL VOID
##
## Ends in an error in state: 188.
##
## xexpr -> xexpr . PIPE xprog [ PIPE COMMA ]
## xprog -> RPHASE LBRACE xexpr . COMMA xreal COMMA xreal RBRACE [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## RPHASE LBRACE xexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: RPHASE LBRACE EXPRVAR COMMA VOID
##
## Ends in an error in state: 189.
##
## xprog -> RPHASE LBRACE xexpr COMMA . xreal COMMA xreal RBRACE [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## RPHASE LBRACE xexpr COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: RPHASE LBRACE EXPRVAR COMMA REALVAR THEN
##
## Ends in an error in state: 190.
##
## xprog -> RPHASE LBRACE xexpr COMMA xreal . COMMA xreal RBRACE [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xreal -> xreal . PLUS xreal [ TIMES POW PLUS MOD MINUS DIV COMMA ]
## xreal -> xreal . TIMES xreal [ TIMES POW PLUS MOD MINUS DIV COMMA ]
## xreal -> xreal . MINUS xreal [ TIMES POW PLUS MOD MINUS DIV COMMA ]
## xreal -> xreal . DIV xreal [ TIMES POW PLUS MOD MINUS DIV COMMA ]
## xreal -> xreal . POW xreal [ TIMES POW PLUS MOD MINUS DIV COMMA ]
## xreal -> xreal . MOD xreal [ TIMES POW PLUS MOD MINUS DIV COMMA ]
##
## The known suffix of the stack is as follows:
## RPHASE LBRACE xexpr COMMA xreal
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: RPHASE LBRACE EXPRVAR COMMA REALVAR COMMA VOID
##
## Ends in an error in state: 191.
##
## xprog -> RPHASE LBRACE xexpr COMMA xreal COMMA . xreal RBRACE [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## RPHASE LBRACE xexpr COMMA xreal COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: RPHASE LBRACE EXPRVAR COMMA REALVAR COMMA REALVAR THEN
##
## Ends in an error in state: 192.
##
## xprog -> RPHASE LBRACE xexpr COMMA xreal COMMA xreal . RBRACE [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xreal -> xreal . PLUS xreal [ TIMES RBRACE POW PLUS MOD MINUS DIV ]
## xreal -> xreal . TIMES xreal [ TIMES RBRACE POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MINUS xreal [ TIMES RBRACE POW PLUS MOD MINUS DIV ]
## xreal -> xreal . DIV xreal [ TIMES RBRACE POW PLUS MOD MINUS DIV ]
## xreal -> xreal . POW xreal [ TIMES RBRACE POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MOD xreal [ TIMES RBRACE POW PLUS MOD MINUS DIV ]
##
## The known suffix of the stack is as follows:
## RPHASE LBRACE xexpr COMMA xreal COMMA xreal
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: TRY NULL VOID
##
## Ends in an error in state: 194.
##
## xexpr -> TRY xexpr . CATCH xexpr [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xexpr -> xexpr . PIPE xprog [ PIPE CATCH ]
##
## The known suffix of the stack is as follows:
## TRY xexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: TRY EXPRVAR CATCH VOID
##
## Ends in an error in state: 195.
##
## xexpr -> TRY xexpr CATCH . xexpr [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## TRY xexpr CATCH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: TRY EXPRVAR CATCH NULL VOID
##
## Ends in an error in state: 196.
##
## xexpr -> TRY xexpr CATCH xexpr . [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xexpr -> xexpr . PIPE xprog [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## TRY xexpr CATCH xexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: EXPRVAR LBRACE LPAREN VBAR
##
## Ends in an error in state: 197.
##
## xexpr -> LPAREN . xexpr COMMA xexpr RPAREN [ RPAREN RBRACE PIPE ELSE COMMA ]
## xexpr -> LPAREN . xexpr RPAREN [ RPAREN RBRACE PIPE ELSE COMMA ]
## xprog -> LPAREN . xprog RPAREN [ RPAREN RBRACE LPAREN ELSE COMMA ]
## xreal -> LPAREN . xreal RPAREN [ TIMES RPAREN RBRACE POW PLUS MOD MINUS ELSE DIV COMMA ]
## xtype -> LPAREN . xtype RPAREN [ TIMES RPAREN RBRACE ELSE COMMA ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: EXPRVAR LBRACE IF VOID
##
## Ends in an error in state: 198.
##
## xexpr -> IF . bexpr THEN xexpr ELSE xexpr ENDIF [ RPAREN RBRACE PIPE ELSE COMMA ]
## xprog -> IF . bexpr THEN xprog ELSE xprog ENDIF [ RPAREN RBRACE LPAREN ELSE COMMA ]
## xreal -> IF . bexpr THEN xreal ELSE xreal ENDIF [ TIMES RPAREN RBRACE POW PLUS MOD MINUS ELSE DIV COMMA ]
## xtype -> IF . bexpr THEN xtype ELSE xtype ENDIF [ TIMES RPAREN RBRACE ELSE COMMA ]
##
## The known suffix of the stack is as follows:
## IF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: EXPRVAR LBRACE IF REALVAR EQUAL REALVAR RPAREN
##
## Ends in an error in state: 199.
##
## bexpr -> bexpr . AND bexpr [ THEN OR AND ]
## bexpr -> bexpr . OR bexpr [ THEN OR AND ]
## xexpr -> IF bexpr . THEN xexpr ELSE xexpr ENDIF [ RPAREN RBRACE PIPE ELSE COMMA ]
## xprog -> IF bexpr . THEN xprog ELSE xprog ENDIF [ RPAREN RBRACE LPAREN ELSE COMMA ]
## xreal -> IF bexpr . THEN xreal ELSE xreal ENDIF [ TIMES RPAREN RBRACE POW PLUS MOD MINUS ELSE DIV COMMA ]
## xtype -> IF bexpr . THEN xtype ELSE xtype ENDIF [ TIMES RPAREN RBRACE ELSE COMMA ]
##
## The known suffix of the stack is as follows:
## IF bexpr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
## In state 94, spurious reduction of production bexpr -> xreal comparison xreal
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: EXPRVAR LBRACE IF REALVAR EQUAL REALVAR THEN VBAR
##
## Ends in an error in state: 200.
##
## xexpr -> IF bexpr THEN . xexpr ELSE xexpr ENDIF [ RPAREN RBRACE PIPE ELSE COMMA ]
## xprog -> IF bexpr THEN . xprog ELSE xprog ENDIF [ RPAREN RBRACE LPAREN ELSE COMMA ]
## xreal -> IF bexpr THEN . xreal ELSE xreal ENDIF [ TIMES RPAREN RBRACE POW PLUS MOD MINUS ELSE DIV COMMA ]
## xtype -> IF bexpr THEN . xtype ELSE xtype ENDIF [ TIMES RPAREN RBRACE ELSE COMMA ]
##
## The known suffix of the stack is as follows:
## IF bexpr THEN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: EXPRVAR LBRACE IF REALVAR EQUAL REALVAR THEN TYPEVAR VOID
##
## Ends in an error in state: 201.
##
## xtype -> xtype . TIMES xtype [ TIMES ELSE ]
## xtype -> IF bexpr THEN xtype . ELSE xtype ENDIF [ VBAR TIMES RPAREN RBRACE ENDIF END ELSE DEFSTART COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## IF bexpr THEN xtype
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: EXPRVAR LBRACE TYPENAME TIMES VBAR
##
## Ends in an error in state: 202.
##
## xtype -> xtype TIMES . xtype [ VBAR TIMES RPAREN RBRACE ENDIF END ELSE DEFSTART COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## xtype TIMES
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF EXPRVAR COLON LPAREN VBAR
##
## Ends in an error in state: 203.
##
## xtype -> LPAREN . xtype RPAREN [ VBAR TIMES RPAREN RBRACE ENDIF END ELSE DEFSTART COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF EXPRVAR COLON IF VOID
##
## Ends in an error in state: 204.
##
## xtype -> IF . bexpr THEN xtype ELSE xtype ENDIF [ VBAR TIMES RPAREN RBRACE ENDIF END ELSE DEFSTART COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## IF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF EXPRVAR COLON IF REALVAR EQUAL REALVAR RPAREN
##
## Ends in an error in state: 205.
##
## bexpr -> bexpr . AND bexpr [ THEN OR AND ]
## bexpr -> bexpr . OR bexpr [ THEN OR AND ]
## xtype -> IF bexpr . THEN xtype ELSE xtype ENDIF [ VBAR TIMES RPAREN RBRACE ENDIF END ELSE DEFSTART COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## IF bexpr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
## In state 94, spurious reduction of production bexpr -> xreal comparison xreal
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF EXPRVAR COLON IF REALVAR EQUAL REALVAR THEN VBAR
##
## Ends in an error in state: 206.
##
## xtype -> IF bexpr THEN . xtype ELSE xtype ENDIF [ VBAR TIMES RPAREN RBRACE ENDIF END ELSE DEFSTART COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## IF bexpr THEN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: EXPRVAR LBRACE LPAREN TYPEVAR VOID
##
## Ends in an error in state: 207.
##
## xtype -> xtype . TIMES xtype [ TIMES RPAREN ]
## xtype -> LPAREN xtype . RPAREN [ VBAR TIMES RPAREN RBRACE ENDIF END ELSE DEFSTART COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## LPAREN xtype
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: EXPRVAR LBRACE IF REALVAR EQUAL REALVAR THEN TYPENAME ELSE VBAR
##
## Ends in an error in state: 210.
##
## xtype -> IF bexpr THEN xtype ELSE . xtype ENDIF [ VBAR TIMES RPAREN RBRACE ENDIF END ELSE DEFSTART COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## IF bexpr THEN xtype ELSE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: EXPRVAR LBRACE IF REALVAR EQUAL REALVAR THEN TYPENAME ELSE TYPEVAR VOID
##
## Ends in an error in state: 211.
##
## xtype -> xtype . TIMES xtype [ TIMES ENDIF ]
## xtype -> IF bexpr THEN xtype ELSE xtype . ENDIF [ VBAR TIMES RPAREN RBRACE ENDIF END ELSE DEFSTART COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## IF bexpr THEN xtype ELSE xtype
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: EXPRVAR LBRACE TYPEVAR VOID
##
## Ends in an error in state: 213.
##
## arglist_item -> xtype . [ RBRACE COMMA ]
## xtype -> xtype . TIMES xtype [ TIMES RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## xtype
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: EXPRVAR LBRACE REALVAR THEN
##
## Ends in an error in state: 214.
##
## arglist_item -> xreal . [ RBRACE COMMA ]
## xreal -> xreal . PLUS xreal [ TIMES RBRACE POW PLUS MOD MINUS DIV COMMA ]
## xreal -> xreal . TIMES xreal [ TIMES RBRACE POW PLUS MOD MINUS DIV COMMA ]
## xreal -> xreal . MINUS xreal [ TIMES RBRACE POW PLUS MOD MINUS DIV COMMA ]
## xreal -> xreal . DIV xreal [ TIMES RBRACE POW PLUS MOD MINUS DIV COMMA ]
## xreal -> xreal . POW xreal [ TIMES RBRACE POW PLUS MOD MINUS DIV COMMA ]
## xreal -> xreal . MOD xreal [ TIMES RBRACE POW PLUS MOD MINUS DIV COMMA ]
##
## The known suffix of the stack is as follows:
## xreal
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: EXPRVAR LBRACE PROGVAR SEMICOLON
##
## Ends in an error in state: 215.
##
## arglist_item -> xprog . [ RBRACE COMMA ]
## xexpr -> xprog . LPAREN xexpr RPAREN [ RBRACE PIPE COMMA ]
## xexpr -> xprog . LPAREN xexpr COMMA xexpr RPAREN [ RBRACE PIPE COMMA ]
##
## The known suffix of the stack is as follows:
## xprog
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 22, spurious reduction of production arglist ->
## In state 23, spurious reduction of production xprog -> PROGVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: EXPRVAR LBRACE NULL VOID
##
## Ends in an error in state: 216.
##
## arglist_item -> xexpr . [ RBRACE COMMA ]
## xexpr -> xexpr . PIPE xprog [ RBRACE PIPE COMMA ]
##
## The known suffix of the stack is as follows:
## xexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: EXPRVAR LBRACE EXPRVAR COMMA VBAR
##
## Ends in an error in state: 220.
##
## arglist_nonempty -> arglist_item COMMA . arglist_nonempty [ RBRACE ]
##
## The known suffix of the stack is as follows:
## arglist_item COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF SIN LPAREN REALVAR THEN
##
## Ends in an error in state: 223.
##
## xreal -> xreal . PLUS xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . TIMES xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MINUS xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . DIV xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . POW xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MOD xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> SIN LPAREN xreal . RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## SIN LPAREN xreal
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF SQRT LPAREN REALVAR THEN
##
## Ends in an error in state: 225.
##
## xreal -> xreal . PLUS xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . TIMES xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MINUS xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . DIV xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . POW xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MOD xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> SQRT LPAREN xreal . RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## SQRT LPAREN xreal
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: IF TAN LPAREN REALVAR THEN
##
## Ends in an error in state: 227.
##
## xreal -> xreal . PLUS xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . TIMES xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MINUS xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . DIV xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . POW xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MOD xreal [ TIMES RPAREN POW PLUS MOD MINUS DIV ]
## xreal -> TAN LPAREN xreal . RPAREN [ TIMES THEN RPAREN RBRACE POW PLUS OR NEQ MOD MINUS LT LEQ GT GEQ EQUAL ENDIF END ELSE DIV COMMA AND ]
##
## The known suffix of the stack is as follows:
## TAN LPAREN xreal
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: U3 LBRACE REALVAR THEN
##
## Ends in an error in state: 229.
##
## xprog -> U3 LBRACE xreal . COMMA xreal COMMA xreal RBRACE [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xreal -> xreal . PLUS xreal [ TIMES POW PLUS MOD MINUS DIV COMMA ]
## xreal -> xreal . TIMES xreal [ TIMES POW PLUS MOD MINUS DIV COMMA ]
## xreal -> xreal . MINUS xreal [ TIMES POW PLUS MOD MINUS DIV COMMA ]
## xreal -> xreal . DIV xreal [ TIMES POW PLUS MOD MINUS DIV COMMA ]
## xreal -> xreal . POW xreal [ TIMES POW PLUS MOD MINUS DIV COMMA ]
## xreal -> xreal . MOD xreal [ TIMES POW PLUS MOD MINUS DIV COMMA ]
##
## The known suffix of the stack is as follows:
## U3 LBRACE xreal
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: U3 LBRACE REALVAR COMMA VOID
##
## Ends in an error in state: 230.
##
## xprog -> U3 LBRACE xreal COMMA . xreal COMMA xreal RBRACE [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## U3 LBRACE xreal COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: U3 LBRACE REALVAR COMMA REALVAR THEN
##
## Ends in an error in state: 231.
##
## xprog -> U3 LBRACE xreal COMMA xreal . COMMA xreal RBRACE [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xreal -> xreal . PLUS xreal [ TIMES POW PLUS MOD MINUS DIV COMMA ]
## xreal -> xreal . TIMES xreal [ TIMES POW PLUS MOD MINUS DIV COMMA ]
## xreal -> xreal . MINUS xreal [ TIMES POW PLUS MOD MINUS DIV COMMA ]
## xreal -> xreal . DIV xreal [ TIMES POW PLUS MOD MINUS DIV COMMA ]
## xreal -> xreal . POW xreal [ TIMES POW PLUS MOD MINUS DIV COMMA ]
## xreal -> xreal . MOD xreal [ TIMES POW PLUS MOD MINUS DIV COMMA ]
##
## The known suffix of the stack is as follows:
## U3 LBRACE xreal COMMA xreal
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: U3 LBRACE REALVAR COMMA REALVAR COMMA VOID
##
## Ends in an error in state: 232.
##
## xprog -> U3 LBRACE xreal COMMA xreal COMMA . xreal RBRACE [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
##
## The known suffix of the stack is as follows:
## U3 LBRACE xreal COMMA xreal COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: U3 LBRACE REALVAR COMMA REALVAR COMMA REALVAR THEN
##
## Ends in an error in state: 233.
##
## xprog -> U3 LBRACE xreal COMMA xreal COMMA xreal . RBRACE [ SEMICOLON RPAREN RBRACKET RBRACE PIPE LPAREN LBRACKET IN EQUAL EOF ENDIF END ELSE COMMA CATCH ARROW ]
## xreal -> xreal . PLUS xreal [ TIMES RBRACE POW PLUS MOD MINUS DIV ]
## xreal -> xreal . TIMES xreal [ TIMES RBRACE POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MINUS xreal [ TIMES RBRACE POW PLUS MOD MINUS DIV ]
## xreal -> xreal . DIV xreal [ TIMES RBRACE POW PLUS MOD MINUS DIV ]
## xreal -> xreal . POW xreal [ TIMES RBRACE POW PLUS MOD MINUS DIV ]
## xreal -> xreal . MOD xreal [ TIMES RBRACE POW PLUS MOD MINUS DIV ]
##
## The known suffix of the stack is as follows:
## U3 LBRACE xreal COMMA xreal COMMA xreal
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: TYPE VOID
##
## Ends in an error in state: 235.
##
## definition -> TYPE . TYPENAME paramsig DEFSTART xtype END [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR EOF DEF CTRL ]
## definition -> TYPE . TYPENAME paramsig DEFSTART constructor_list END [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR EOF DEF CTRL ]
##
## The known suffix of the stack is as follows:
## TYPE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: TYPE TYPENAME VOID
##
## Ends in an error in state: 236.
##
## definition -> TYPE TYPENAME . paramsig DEFSTART xtype END [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR EOF DEF CTRL ]
## definition -> TYPE TYPENAME . paramsig DEFSTART constructor_list END [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR EOF DEF CTRL ]
##
## The known suffix of the stack is as follows:
## TYPE TYPENAME
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF EXPRVAR LBRACE VOID
##
## Ends in an error in state: 237.
##
## paramsig -> LBRACE . paramsig_nonempty RBRACE [ DEFSTART COLON ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF EXPRVAR LBRACE PROGVAR VOID
##
## Ends in an error in state: 240.
##
## paramsig_item -> PROGVAR . COLON xprogtype [ RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## PROGVAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF EXPRVAR LBRACE PROGVAR COLON VBAR
##
## Ends in an error in state: 241.
##
## paramsig_item -> PROGVAR COLON . xprogtype [ RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## PROGVAR COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF PROGVAR COLON LPAREN VBAR
##
## Ends in an error in state: 242.
##
## xprogtype -> LPAREN . xprogtype RPAREN [ RPAREN RBRACE DEFSTART COMMA ]
## xtype -> LPAREN . xtype RPAREN [ TIMES RPAREN ARROW ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF PROGVAR COLON LPAREN TYPEVAR VOID
##
## Ends in an error in state: 243.
##
## xprogtype -> xtype . ARROW xtype [ RPAREN ]
## xtype -> xtype . TIMES xtype [ TIMES RPAREN ARROW ]
## xtype -> LPAREN xtype . RPAREN [ TIMES RPAREN ARROW ]
##
## The known suffix of the stack is as follows:
## LPAREN xtype
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF PROGVAR COLON TYPENAME ARROW VBAR
##
## Ends in an error in state: 244.
##
## xprogtype -> xtype ARROW . xtype [ RPAREN RBRACE DEFSTART COMMA ]
##
## The known suffix of the stack is as follows:
## xtype ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF PROGVAR COLON TYPENAME ARROW TYPEVAR VOID
##
## Ends in an error in state: 245.
##
## xprogtype -> xtype ARROW xtype . [ RPAREN RBRACE DEFSTART COMMA ]
## xtype -> xtype . TIMES xtype [ TIMES RPAREN RBRACE DEFSTART COMMA ]
##
## The known suffix of the stack is as follows:
## xtype ARROW xtype
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF PROGVAR COLON LPAREN TYPENAME ARROW TYPENAME RBRACE
##
## Ends in an error in state: 246.
##
## xprogtype -> LPAREN xprogtype . RPAREN [ RPAREN RBRACE DEFSTART COMMA ]
##
## The known suffix of the stack is as follows:
## LPAREN xprogtype
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 16, spurious reduction of production arglist ->
## In state 17, spurious reduction of production xtype -> TYPENAME arglist
## In state 245, spurious reduction of production xprogtype -> xtype ARROW xtype
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF PROGVAR COLON TYPEVAR VOID
##
## Ends in an error in state: 248.
##
## xprogtype -> xtype . ARROW xtype [ RBRACE DEFSTART COMMA ]
## xtype -> xtype . TIMES xtype [ TIMES ARROW ]
##
## The known suffix of the stack is as follows:
## xtype
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF EXPRVAR LBRACE EXPRVAR VOID
##
## Ends in an error in state: 250.
##
## paramsig_item -> EXPRVAR . COLON xtype [ RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## EXPRVAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF EXPRVAR LBRACE EXPRVAR COLON VBAR
##
## Ends in an error in state: 251.
##
## paramsig_item -> EXPRVAR COLON . xtype [ RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## EXPRVAR COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF EXPRVAR LBRACE EXPRVAR COLON TYPEVAR VOID
##
## Ends in an error in state: 252.
##
## paramsig_item -> EXPRVAR COLON xtype . [ RBRACE COMMA ]
## xtype -> xtype . TIMES xtype [ TIMES RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## EXPRVAR COLON xtype
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF EXPRVAR LBRACE REALVAR VOID
##
## Ends in an error in state: 255.
##
## paramsig_nonempty -> paramsig_item . [ RBRACE ]
## paramsig_nonempty -> paramsig_item . COMMA paramsig_nonempty [ RBRACE ]
##
## The known suffix of the stack is as follows:
## paramsig_item
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF EXPRVAR LBRACE REALVAR COMMA VOID
##
## Ends in an error in state: 256.
##
## paramsig_nonempty -> paramsig_item COMMA . paramsig_nonempty [ RBRACE ]
##
## The known suffix of the stack is as follows:
## paramsig_item COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: TYPE TYPENAME LBRACE REALVAR RBRACE VOID
##
## Ends in an error in state: 258.
##
## definition -> TYPE TYPENAME paramsig . DEFSTART xtype END [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR EOF DEF CTRL ]
## definition -> TYPE TYPENAME paramsig . DEFSTART constructor_list END [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR EOF DEF CTRL ]
##
## The known suffix of the stack is as follows:
## TYPE TYPENAME paramsig
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: TYPE TYPENAME DEFSTART U3
##
## Ends in an error in state: 259.
##
## definition -> TYPE TYPENAME paramsig DEFSTART . xtype END [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR EOF DEF CTRL ]
## definition -> TYPE TYPENAME paramsig DEFSTART . constructor_list END [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR EOF DEF CTRL ]
##
## The known suffix of the stack is as follows:
## TYPE TYPENAME paramsig DEFSTART
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: TYPE TYPENAME DEFSTART VBAR VOID
##
## Ends in an error in state: 260.
##
## constructor_list -> VBAR . constructor_list1 [ END ]
##
## The known suffix of the stack is as follows:
## VBAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: TYPE TYPENAME DEFSTART PROGVAR VOID
##
## Ends in an error in state: 261.
##
## constructor_list1 -> PROGVAR . OF xtype [ END ]
## constructor_list1 -> PROGVAR . OF xtype VBAR constructor_list1 [ END ]
##
## The known suffix of the stack is as follows:
## PROGVAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: TYPE TYPENAME DEFSTART PROGVAR OF VBAR
##
## Ends in an error in state: 262.
##
## constructor_list1 -> PROGVAR OF . xtype [ END ]
## constructor_list1 -> PROGVAR OF . xtype VBAR constructor_list1 [ END ]
##
## The known suffix of the stack is as follows:
## PROGVAR OF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: TYPE TYPENAME DEFSTART PROGVAR OF TYPEVAR VOID
##
## Ends in an error in state: 263.
##
## constructor_list1 -> PROGVAR OF xtype . [ END ]
## constructor_list1 -> PROGVAR OF xtype . VBAR constructor_list1 [ END ]
## xtype -> xtype . TIMES xtype [ VBAR TIMES END ]
##
## The known suffix of the stack is as follows:
## PROGVAR OF xtype
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: TYPE TYPENAME DEFSTART PROGVAR OF TYPENAME VBAR VOID
##
## Ends in an error in state: 264.
##
## constructor_list1 -> PROGVAR OF xtype VBAR . constructor_list1 [ END ]
##
## The known suffix of the stack is as follows:
## PROGVAR OF xtype VBAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: TYPE TYPENAME DEFSTART EXPRVAR VOID
##
## Ends in an error in state: 265.
##
## constructor_list1 -> EXPRVAR . [ END ]
## constructor_list1 -> EXPRVAR . VBAR constructor_list1 [ END ]
##
## The known suffix of the stack is as follows:
## EXPRVAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: TYPE TYPENAME DEFSTART EXPRVAR VBAR VOID
##
## Ends in an error in state: 266.
##
## constructor_list1 -> EXPRVAR VBAR . constructor_list1 [ END ]
##
## The known suffix of the stack is as follows:
## EXPRVAR VBAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: TYPE TYPENAME DEFSTART TYPEVAR VOID
##
## Ends in an error in state: 270.
##
## definition -> TYPE TYPENAME paramsig DEFSTART xtype . END [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR EOF DEF CTRL ]
## xtype -> xtype . TIMES xtype [ TIMES END ]
##
## The known suffix of the stack is as follows:
## TYPE TYPENAME paramsig DEFSTART xtype
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF VOID
##
## Ends in an error in state: 275.
##
## definition -> DEF . EXPRVAR paramsig COLON xtype DEFSTART xexpr END [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR EOF DEF CTRL ]
## definition -> DEF . PROGVAR paramsig COLON xprogtype DEFSTART xprog END [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR EOF DEF CTRL ]
## definition -> DEF . REALVAR paramsig DEFSTART xreal END [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR EOF DEF CTRL ]
##
## The known suffix of the stack is as follows:
## DEF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF REALVAR VOID
##
## Ends in an error in state: 276.
##
## definition -> DEF REALVAR . paramsig DEFSTART xreal END [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR EOF DEF CTRL ]
##
## The known suffix of the stack is as follows:
## DEF REALVAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF REALVAR LBRACE REALVAR RBRACE VOID
##
## Ends in an error in state: 277.
##
## definition -> DEF REALVAR paramsig . DEFSTART xreal END [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR EOF DEF CTRL ]
##
## The known suffix of the stack is as follows:
## DEF REALVAR paramsig
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF REALVAR DEFSTART VOID
##
## Ends in an error in state: 278.
##
## definition -> DEF REALVAR paramsig DEFSTART . xreal END [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR EOF DEF CTRL ]
##
## The known suffix of the stack is as follows:
## DEF REALVAR paramsig DEFSTART
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF REALVAR DEFSTART REALVAR THEN
##
## Ends in an error in state: 279.
##
## definition -> DEF REALVAR paramsig DEFSTART xreal . END [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR EOF DEF CTRL ]
## xreal -> xreal . PLUS xreal [ TIMES POW PLUS MOD MINUS END DIV ]
## xreal -> xreal . TIMES xreal [ TIMES POW PLUS MOD MINUS END DIV ]
## xreal -> xreal . MINUS xreal [ TIMES POW PLUS MOD MINUS END DIV ]
## xreal -> xreal . DIV xreal [ TIMES POW PLUS MOD MINUS END DIV ]
## xreal -> xreal . POW xreal [ TIMES POW PLUS MOD MINUS END DIV ]
## xreal -> xreal . MOD xreal [ TIMES POW PLUS MOD MINUS END DIV ]
##
## The known suffix of the stack is as follows:
## DEF REALVAR paramsig DEFSTART xreal
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 11, spurious reduction of production arglist ->
## In state 222, spurious reduction of production xreal -> REALVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF PROGVAR VOID
##
## Ends in an error in state: 281.
##
## definition -> DEF PROGVAR . paramsig COLON xprogtype DEFSTART xprog END [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR EOF DEF CTRL ]
##
## The known suffix of the stack is as follows:
## DEF PROGVAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF PROGVAR LBRACE REALVAR RBRACE VOID
##
## Ends in an error in state: 282.
##
## definition -> DEF PROGVAR paramsig . COLON xprogtype DEFSTART xprog END [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR EOF DEF CTRL ]
##
## The known suffix of the stack is as follows:
## DEF PROGVAR paramsig
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF PROGVAR COLON VBAR
##
## Ends in an error in state: 283.
##
## definition -> DEF PROGVAR paramsig COLON . xprogtype DEFSTART xprog END [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR EOF DEF CTRL ]
##
## The known suffix of the stack is as follows:
## DEF PROGVAR paramsig COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF PROGVAR COLON TYPENAME ARROW TYPENAME RPAREN
##
## Ends in an error in state: 284.
##
## definition -> DEF PROGVAR paramsig COLON xprogtype . DEFSTART xprog END [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR EOF DEF CTRL ]
##
## The known suffix of the stack is as follows:
## DEF PROGVAR paramsig COLON xprogtype
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 16, spurious reduction of production arglist ->
## In state 17, spurious reduction of production xtype -> TYPENAME arglist
## In state 245, spurious reduction of production xprogtype -> xtype ARROW xtype
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF PROGVAR COLON TYPENAME ARROW TYPENAME DEFSTART VOID
##
## Ends in an error in state: 285.
##
## definition -> DEF PROGVAR paramsig COLON xprogtype DEFSTART . xprog END [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR EOF DEF CTRL ]
##
## The known suffix of the stack is as follows:
## DEF PROGVAR paramsig COLON xprogtype DEFSTART
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF PROGVAR COLON TYPENAME ARROW TYPENAME DEFSTART PROGVAR SEMICOLON
##
## Ends in an error in state: 286.
##
## definition -> DEF PROGVAR paramsig COLON xprogtype DEFSTART xprog . END [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR EOF DEF CTRL ]
##
## The known suffix of the stack is as follows:
## DEF PROGVAR paramsig COLON xprogtype DEFSTART xprog
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 22, spurious reduction of production arglist ->
## In state 23, spurious reduction of production xprog -> PROGVAR arglist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF EXPRVAR VOID
##
## Ends in an error in state: 288.
##
## definition -> DEF EXPRVAR . paramsig COLON xtype DEFSTART xexpr END [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR EOF DEF CTRL ]
##
## The known suffix of the stack is as follows:
## DEF EXPRVAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF EXPRVAR LBRACE REALVAR RBRACE VOID
##
## Ends in an error in state: 289.
##
## definition -> DEF EXPRVAR paramsig . COLON xtype DEFSTART xexpr END [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR EOF DEF CTRL ]
##
## The known suffix of the stack is as follows:
## DEF EXPRVAR paramsig
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF EXPRVAR COLON VBAR
##
## Ends in an error in state: 290.
##
## definition -> DEF EXPRVAR paramsig COLON . xtype DEFSTART xexpr END [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR EOF DEF CTRL ]
##
## The known suffix of the stack is as follows:
## DEF EXPRVAR paramsig COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF EXPRVAR COLON TYPEVAR VOID
##
## Ends in an error in state: 291.
##
## definition -> DEF EXPRVAR paramsig COLON xtype . DEFSTART xexpr END [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR EOF DEF CTRL ]
## xtype -> xtype . TIMES xtype [ TIMES DEFSTART ]
##
## The known suffix of the stack is as follows:
## DEF EXPRVAR paramsig COLON xtype
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF EXPRVAR COLON TYPENAME DEFSTART VOID
##
## Ends in an error in state: 292.
##
## definition -> DEF EXPRVAR paramsig COLON xtype DEFSTART . xexpr END [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR EOF DEF CTRL ]
##
## The known suffix of the stack is as follows:
## DEF EXPRVAR paramsig COLON xtype DEFSTART
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: DEF EXPRVAR COLON TYPENAME DEFSTART NULL VOID
##
## Ends in an error in state: 293.
##
## definition -> DEF EXPRVAR paramsig COLON xtype DEFSTART xexpr . END [ U3 TYPE TRY RPHASE QVAR PROGVAR PMATCH NULL MATCH LPAREN LET LAMBDA IF GPHASE EXPRVAR EOF DEF CTRL ]
## xexpr -> xexpr . PIPE xprog [ PIPE END ]
##
## The known suffix of the stack is as follows:
## DEF EXPRVAR paramsig COLON xtype DEFSTART xexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunityfile: NULL VOID
##
## Ends in an error in state: 295.
##
## qunityfile -> deflist xexpr . EOF [ # ]
## xexpr -> xexpr . PIPE xprog [ PIPE EOF ]
##
## The known suffix of the stack is as follows:
## deflist xexpr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

qunitylib: VOID
##
## Ends in an error in state: 300.
##
## deflist -> deflist . definition [ TYPE EOF DEF ]
## qunitylib -> deflist . EOF [ # ]
##
## The known suffix of the stack is as follows:
## deflist
##

<YOUR SYNTAX ERROR MESSAGE HERE>

