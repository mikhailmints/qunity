def Bit := qunit + qunit end

def Bit0 := left {qunit, qunit} of () end

def Bit1 := right {qunit, qunit} of () end

def BitPlus := Had of Bit0 end

def BitMinus := Had of Bit1 end

def Had := u3 {pi/2, 0, pi} end

def Qnot := u3 {pi, 0, pi} end

def Adjoint <F, T> :=
    lambda (F of x) {T} -> x
end

def Qid <T> :=
    lambda x {T} -> x
end

def Const0 <T> :=
    lambda x {T} -> Bit0
end

def Const1 <T> :=
    lambda x {T} -> Bit1
end

def Fst <T0, T1> :=
    lambda (x0, x1) {T0 * T1} -> x0
end

def Snd <T0, T1> :=
    lambda (x0, x1) {T0 * T1} -> x1
end

def NTensorT <N, T> :=
    if N = [0] then
        qunit
    else
        T * NTensorT <[N - 1], T>
    endif
end

def NTensorE <N, E> :=
    if N = [0] then
        ()
    else
        (E, NTensorE <[N - 1], E>)
    endif
end

def NTensorF <N, F, T> :=
    if N = [0] then
        Qid <qunit>
    else
        lambda (x, x') {NTensorT <N, T>} ->
        (F of x, NTensorF <[N - 1], F, T> of x')
    endif
end

def Equals <T, E> :=
    lambda x {T} -> try x |> lambda E {T} -> Bit1 catch Bit0
end
