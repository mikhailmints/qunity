# Compilation Process

A Qunity expression/program is converted into an intermediate representation. This intermediate representation is a simple imperative language for high-level quantum circuits, which contains a certain set of Kraus operators and trace non-increasing superoperators as primitives - the ones that are defined in Appendix H.1 of Voichick et al. This intermediate language is detailed in another document here. This representation is then converted into _circuit specifications_, which wrap functions taking in an input register and a set of used wires, and output a _circuit_, which wraps a _unitary_ gate.

## Unitaries

The bottom level of the process is the unitary. A unitary gate can be a single-qubit $U_3(\theta, \phi, \lambda)$ gate, a controlled gate using any number of qubits as controls or anti-controls (as specified by Boolean flags - note that an anti-control is equivalent to a regular control surrounded by Pauli $X$-gates), or a sequence of unitary gates. Each gate specifies which qubits it applies to with integer labels. This can be directly translated into Qiskit or OpenQASM.

## Circuits and Circuit Specifications

A circuit contains a unitary gate, but it also contains information about the quantum registers used in it and the role they play. In order to be able to implement Kraus operators and trace non-increasing superoperators in terms of unitaries, we have to introduce ancillary qubits to form _prep_, _flag_, and _garbage_ registers. This is described in Section 6.3 and Appendix H.1 of Voichick et al. A circuit also stores a set of wires that have been used in some registers when the circuit is created, including those outside it. This way, when creating a new circuit, we can be sure that the prep wires used are fresh wires and not qubits that are already in use.

A circuit specification is a wrapper around a function for constructing a given circuit given any input register of the correct size. This is useful, because using this structure allows us to avoid having to relabel the wires after a complete circuit has already been constructed any time we want to build a circuit out of smaller circuits (except in some cases like taking the adjoint, where we still need to relabel).

We can describe circuit specifications for various kinds of operators that will be used as primitives in the intermediate-level language (high-level circuit) representation of a Qunity program. For example, given circuit specifications for some operators $E_0$ and $E_1$, we can construct circuit specifications for the tensor product $E_0 \otimes E_1$ and the direct sum $E_0 \oplus E_1$. We can convert a trace non-increasing superoperator $\mathcal{E}(\rho)$ to a trace-preserving superoperator $\mathcal{E}(\rho) \oplus (\mathrm{tr}(\rho) - \mathrm{tr}(\mathcal{E}(\rho)))$ by flipping a signal bit controlled on the state of the flag qubits (and also performing a controlled swap of the output with a fresh prep/garbage register to ensure the direct sum is correctly encoded). When implementing these, we can describe a function on an input register that creates a fresh prep register of the necessary size, then rearranges the qubits in the input and prep registers into the output, flag, and garbage registers, and describes a unitary gate acting on these registers.
