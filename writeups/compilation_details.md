# Compilation Process

A Qunity file is parsed into Qunity with extended syntax (which allows for definitions). This is then pre-processed, converting it into the core Qunity language. Then Qunity expressions are converted into an intermediate representation. This intermediate representation is a simple language for high-level quantum circuits, which contains a certain set of Kraus operators and trace non-increasing superoperators as primitives - the ones that are defined in Appendix H.1 of Voichick et al. This intermediate representation is detailed in another document here. This representation is then converted into _circuit specifications_, which wrap functions that, given some input registers, output a _circuit_, which wraps a _gate_. After this is done, the resulting specification is instantiated into a circuit, and post-processed by removing identity gates. Then, the circuit is converted into Qiskit code, from which OpenQASM can be extracted.

## Gates

A _gate_ is one of: (1) The identity, which does nothing and does not have any specific target qubits. (2) A single-qubit unitary gate, which can in general be represented by a $U_3(\theta, \phi, \lambda)$ gate. (3) A global phase gate that applies a given global phase to a list of qubits - note that this does not have any physical significance on its own, but can turn ino a relative phase gate if it is controlled. (4) The reset gate, which measures a qubit and resets it to the $|0\rangle$ state - this is not a unitary operation. (5) A controlled gate using any number of qubits as controls or anti-controls (as specified by Boolean flags - note that an anti-control is equivalent to a regular control surrounded by Pauli $X$-gates). (6) A sequence of two gates.

## Circuits and Circuit Specifications

A circuit contains a gate, but it also contains information about the quantum registers used in it and the role they play. In order to be able to implement Kraus operators and trace non-increasing superoperators in terms of unitaries, we have to introduce ancillary qubits to form _prep_, _flag_, and _garbage_ registers. This is described in Section 6.3 and Appendix H.1 of Voichick et al. A circuit also stores a set of wires that have been used in some registers when the circuit is created, including those outside it. This way, when creating a new circuit, we can be sure that the prep wires used are fresh wires and not qubits that are already in use.

A circuit specification is a wrapper around a function for constructing a given circuit given any input register of the correct size. The function takes in an input register as a list of integers, as well as a set of used wires and a Boolean flag for whether to reset the garbage register of the circuit. This construction is useful, because using this structure allows us to avoid having to relabel the wires after a complete circuit has already been constructed any time we want to build a circuit out of smaller circuits (except in some cases like taking the adjoint, where we still need to relabel, but it is relatively manageable).

We can describe circuit specifications for various kinds of operators that will be used as primitives in the intermediate (high-level circuit) representation of a Qunity program.For example, given circuit specifications for some operators $E_0$ and $E_1$, we can construct circuit specifications for the tensor product $E_0 \otimes E_1$ and the direct sum $E_0 \oplus E_1$. We can convert a trace non-increasing superoperator $\mathcal{E}(\rho)$ to a trace-preserving superoperator $\mathcal{E}(\rho) \oplus (\mathrm{tr}(\rho) - \mathrm{tr}(\mathcal{E}(\rho)))$ by flipping a signal bit controlled on the state of the flag qubits (and also performing a controlled swap of the output with a fresh prep/garbage register to ensure the direct sum is correctly encoded). When implementing these, we can describe a function on an input register that creates a fresh prep register of the necessary size, then rearranges the qubits in the input and prep registers into the output, flag, and garbage registers, and describes a unitary gate acting on these registers.
