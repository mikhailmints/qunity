/*
Qunity standard library definitions, added to the start of every file
*/

type Bit := $0 | $1 end

def $Plus : Bit := @Had($0) end

def $Minus : Bit := @Had($1) end

def @Had : Bit -> Bit := u3 {pi/2, 0, pi} end

def @Not : Bit -> Bit := @PauliX end

def @PauliX : Bit -> Bit := u3 {pi, 0, pi} end

def @PauliY : Bit -> Bit := u3 {pi, pi/2, pi/2} end

def @PauliZ : Bit -> Bit := u3 {0, pi, 0} end

def @Adjoint {'a, 'b, @F : 'a -> 'b} : 'b -> 'a :=
    lambda @F(x) -> x
end

def @Id {'a} : 'a -> 'a :=
    lambda x -> x
end

def @Const0 {'a} : 'a -> Bit :=
    lambda x -> $0
end

def @Const1 {'a} : 'a -> Bit :=
    lambda x -> $1
end

def @Fst {'a, 'b} : ('a * 'b) -> 'a :=
    lambda (x0, x1) -> x0
end

def @Snd {'a, 'b} : ('a * 'b) -> 'b :=
    lambda (x0, x1) -> x1
end

type Maybe {'a} :=
    | $Nothing
    | @Just of 'a
end

/*
Tensor product of type T, N times
*/
type NTensorT {#N, 'a} :=
    if #N <= 0 then
        Unit
    else
        'a * NTensorT {#N - 1, 'a}
    endif
end

type Num {#N} := NTensorT {#N, Bit} end

/*
Tensor product of expression E, N times
*/
def $NTensorE {#N, 'a, $E : 'a} : NTensorT {#N, 'a} :=
    if #N <= 0 then
        ()
    else
        ($E, $NTensorE {#N - 1, 'a, $E})
    endif
end

/*
Tensor product of program F, acting on type T, N times
*/
def @NTensorF {#N, 'a, 'b, @F : 'a -> 'b} : NTensorT {#N, 'a} -> NTensorT {#N, 'b} :=
    if #N <= 0 then
        @Id {Unit}
    else
        lambda (x, x') -> (@F(x), @NTensorF {#N - 1, 'a, 'b, @F} (x'))
    endif
end

def @Append {#N, 'a} : NTensorT {#N, 'a} * 'a -> NTensorT {#N + 1, 'a} :=
    if #N <= 0 then
        lambda (y, x) -> (x, y)
    else
        lambda ((y0, y1), x) -> (y0, @Append {#N - 1, 'a} (y1, x))
    endif
end

def @Concat {#N0, #N1, 'a} : NTensorT {#N0, 'a} * NTensorT {#N1, 'a} -> NTensorT {#N0 + #N1, 'a} :=
    if #N1 <= 0 then
        lambda (a, ()) -> a
    else
        lambda (a, (b, b')) ->
            @Concat {#N0 + 1, #N1 - 1, 'a} (@Append {#N0, 'a} (a, b), b')
    endif
end

def @Reverse {#N, 'a} : NTensorT {#N, 'a} -> NTensorT {#N, 'a} :=
    if #N <= 0 then
        @Id {Unit}
    else
        lambda (x, y) ->
            @Append {#N - 1, 'a} (@Reverse {#N - 1, 'a} (y), x)
    endif
end

def @Equals {'a, $E : 'a} : 'a -> Bit :=
    lambda x -> try x |> lambda $E -> $1 catch $0
end

def @Reflect {'a, $E : 'a} : 'a -> 'a :=
    rphase {$E, 0, pi}
end

/*
Little-endian encoding of number N as a quantum state
*/
def $NumToStateLE {#N, #Nbits} : Num {#Nbits} :=
    if #N <= 0 then
        $NTensorE {#Nbits, Bit, $0}
    else
        if #N % 2 = 0 then
            ($0, $NumToStateLE {#N / 2, #Nbits - 1})
        else
            ($1, $NumToStateLE {(#N - 1) / 2, #Nbits - 1})
        endif
    endif
end

/*
Big-endian encoding of number N as a quantum state
*/
def $NumToStateBE {#N, #Nbits} : Num {#Nbits} :=
    $NumToStateLE {#N, #Nbits} |> @Reverse {#Nbits, Bit}
end

/*
Increment a little-endian N-bit number
*/
def @IncrementLE {#N} : Num {#N} -> Num {#N} :=
    if #N <= 0 then
        @Id {Unit}
    else
        pmatch [
            ($0, x) -> ($1, x);
            ($1, x) -> ($0, x |> @IncrementLE {#N - 1})
        ]
    endif
end

/*
Decrement a little-endian N-bit number
*/
def @DecrementLE {#N} : Num {#N} -> Num {#N} :=
    @Adjoint {Num {#N}, Num {#N}, @IncrementLE {#N}}
end

/*
Increment a big-endian N-bit number
*/
def @IncrementBE {#N} : Num {#N} -> Num {#N} :=
    lambda x ->
    x |> @Reverse {#N, Bit} |> @IncrementLE {#N} |> @Reverse {#N, Bit}
end

/*
Decrement a big-endian N-bit number
*/
def @DecrementBE {#N} : Num {#N} -> Num {#N} :=
    @Adjoint {Num {#N}, Num {#N}, @DecrementLE {#N}}
end

/*
Retries an evaluation of E N times, amplifying the probability of success
*/
def $Retry {#N, 'a, $E : 'a} : 'a :=
    if #N <= 0 then
        $E
    else
        try $E catch $Retry {#N - 1, 'a, $E}
    endif
end

def @And : Bit * Bit -> Bit :=
    lambda x -> match x [
        ($1, $1) -> $1;
        else -> $0;
    ]
end

/*
Utilities for the Quantum Fourier Transform
*/
def @Couple {#K} : Bit * Bit -> Bit * Bit :=
    lambda (x0, x1) -> (x1, x0) |> rphase {($1, $1), 2 * pi / (2 ^ #K), 0}
end

def @Rotations {#N} : NTensorT {#N, Bit} -> NTensorT {#N, Bit} :=
    if #N <= 0 then
        @Id {Unit}
    else if #N = 1 then
        lambda (x, ()) -> (@Had(x), ())
    else
        lambda (x0, x) ->
            let (x0, (y0', y)) = (x0, @Rotations {#N - 1} (x)) in
            let ((y0, y1), y) = (@Couple {#N} (x0, y0'), y) in
            (y0, (y1, y))
    endif
    endif
end

def @Qft {#N} : NTensorT {#N, Bit} -> NTensorT {#N, Bit} :=
    if #N <= 0 then
        @Id {Unit}
    else
        lambda x ->
            let (x0, x') = @Rotations {#N} (x) in
            (x0, @Qft {#N - 1} (x'))
    endif
end

/*
Using Qunity to construct circuits in the style of the standard circuit model.
By using the following constructions, we can write quantum circuits in terms of
single-qubit gates and the CNOT gate.
*/

def @Gate1Q {#N, #I, @F : Bit -> Bit} : NTensorT {#N, Bit} -> NTensorT {#N, Bit} :=
    if #I <= 0 then
        lambda (x, y) -> (@F(x), y)
    else
        lambda (x, y) -> (x, @Gate1Q {#N - 1, #I - 1, @F} (y))
    endif
end

def @Controlled1Q {#N, #I, #J, @F : Bit -> Bit} : NTensorT {#N, Bit} -> NTensorT {#N, Bit} :=
    if #I > #J then
        lambda x -> x
        |> @Reverse {#N, Bit}
        |> @Controlled1Q {#N, #N - 1 - #I, #N - 1 - #J, @F}
        |> @Reverse {#N, Bit}
    else
        if #I <= 0 then
            lambda (x, y) -> ctrl x [
                $0 -> (x, y);
                $1 -> (x, @Gate1Q {#N - 1, #J - 1, @F} (y))
            ]
        else
            lambda (x, y) -> (x, @Cnot {#N - 1, #I - 1, #J - 1} (y))
        endif
    endif
end

def @Cnot {#N, #I, #J} : NTensorT {#N, Bit} -> NTensorT {#N, Bit} :=
    @Controlled1Q {#N, #I, #J, @Not}
end

type List{#N, 'a} :=
    | $ListEmpty
    | @ListCons of
        if #N <= 0 then
            Void
        else
            'a * List{#N - 1, 'a}
        endif
end

def @ListAppend{#N, 'a} : List{#N, 'a} * 'a -> List{#N, 'a} :=
    if #N <= 0 then
        lambda _ -> ctrl () []
    else
        lambda (l, x) -> match l [
            $ListEmpty{#N, 'a} -> @ListCons{#N, 'a}(x, $ListEmpty{#N - 1, 'a});
            @ListCons{#N, 'a}(x', l') -> @ListCons{#N, 'a}(x', @ListAppend{#N - 1, 'a}(l', x))
        ]
    endif
end

def @ListAppendConst{#N, 'a, $X : 'a} : List{#N, 'a} -> List{#N, 'a} :=
    lambda l -> @ListAppend{#N, 'a}(l, $X)
end

def @ListUpcast{#N, 'a} : List{#N, 'a} -> List{#N + 1, 'a} :=
    if #N <= 0 then
        lambda _ -> $ListEmpty{1, 'a}
    else
        lambda l -> match l [
            $ListEmpty{#N, 'a} -> $ListEmpty{#N + 1, 'a};
            @ListCons{#N, 'a}(x', l') ->
                @ListCons{#N + 1, 'a}(x', @ListUpcast{#N - 1, 'a}(l'))
        ]
    endif
end

def @ListDowncast{#N, 'a} : List{#N, 'a} -> List{#N - 1, 'a} :=
    if #N <= 0 then
        lambda _ -> ctrl () []
    else if #N = 1 then
        lambda $ListEmpty{#N, 'a} -> $ListEmpty{#N - 1, 'a}
    else
        lambda l -> match l [
            $ListEmpty{#N, 'a} -> $ListEmpty{#N - 1, 'a};
            @ListCons{#N, 'a}(x', l') ->
                @ListCons{#N - 1, 'a}(x', @ListDowncast {#N - 1, 'a} (l'))
        ]
    endif
    endif
end

def @ListCastTo{#N, 'a, #N'} : List{#N, 'a} -> List{#N', 'a} :=
    if #N' = #N then
        lambda l -> l
    else
        if #N' > #N then
            lambda l -> @ListCastTo{#N + 1, 'a, #N'}(@ListUpcast {#N, 'a}(l))
        else
            lambda l -> @ListCastTo{#N - 1, 'a, #N'}(@ListDowncast {#N, 'a}(l))
        endif
    endif
end

def @ListHead{#N, 'a} : List{#N, 'a} -> 'a :=
    if #N <= 0 then
        lambda _ -> ctrl () []
    else
        lambda @ListCons{#N, 'a}(x, l') -> x
    endif
end

def @ListTail{#N, 'a} : List{#N, 'a} -> List{#N - 1, 'a} :=
    if #N <= 0 then
        lambda _ -> ctrl () []
    else
        lambda @ListCons{#N, 'a}(x, l') -> l'
    endif
end

def @ListLength{#N, 'a, #Nbits} : List{#N, 'a} -> Num{#Nbits} :=
    if #N <= 0 then
        lambda l -> $NumToStateLE{0, #Nbits}
    else
        lambda l -> match l [
            $ListEmpty{#N, 'a} -> $NumToStateLE{0, #Nbits};
            @ListCons{#N, 'a}(x', l') ->
                @IncrementLE{#Nbits}(@ListLength{#N - 1, 'a, #Nbits}(l'))
        ]
    endif
end
